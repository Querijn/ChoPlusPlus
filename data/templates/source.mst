// This file is automatically generated!
// To edit this, edit template/source.mst and run cho_generator.
#include <cho/generated/riot_api_data.hpp>
#include <cho/generated/riot_api_platform.hpp>
#include <cho/riot_api_request.hpp>
#include <cho_json/json.hpp>
#include <cho/hash.hpp>

#include <thread>

namespace cho
{
	template<typename ... Args>
	std::string string_format(const std::string& format, Args ... args)
	{
		size_t size = snprintf(nullptr, 0, format.c_str(), args ...) + 1;
		if( size <= 0 )
			throw std::runtime_error("Error during size evaluation of string_format, cannot determine end size of string!");

		if (size < 1024)
		{
			char buf[1024];
			snprintf(buf, size, format.c_str(), args...);
			return std::string(buf, buf + size - 1);
		}
		else
		{
			std::unique_ptr<char[]> buf(new char[ size ]);
			snprintf(buf.get(), size, format.c_str(), args ...);
			return std::string(buf.get(), buf.get() + size - 1);
		}
	}

	std::string to_string(const cho::champion_key& a_type)
	{
		return std::to_string(static_cast<int32_t>(a_type));
	}

	std::string to_string(const std::string& a_type)
	{
		return a_type;
	}

	template<typename T>
	void setup_optional_argument(std::string& a_path, const char* a_name, const T& a_elem, bool& a_is_first)
	{
		a_path += a_is_first ? '?' : '&';
		a_path += a_name;
		a_path += '=';
		a_path += to_string(a_elem);
		a_is_first = false;
	}

	template<typename T>
	void setup_optional_argument(std::string& a_path, const char* a_name, const std::vector<T>& a_vector, bool& a_is_first)
	{
		for (auto& elem : a_vector)
			setup_optional_argument(a_path, a_name, elem, a_is_first);
	}

	template<typename T>
	void setup_optional_argument(std::string& a_path, const char* a_name, cho::optional<T> a_elem, bool& a_is_first)
	{
		if (a_elem.filled == false)
			return;

		setup_optional_argument(a_path, a_name, a_elem.value, a_is_first);
	}

	platform_id get_platform_by_string(const char* a_platform_string)
	{
		switch (cho::crc32_lc(a_platform_string, strlen(a_platform_string)))
		{
			default:
		{{#platforms}}
			case COMPILE_TIME_CRC32_LC_STR("{{platform}}"): return platform_id::{{platform}};
		{{/platforms}}
		}
	}

	static std::vector<const char*> g_riot_api_servers =
	{
	{{#platforms}}
		"{{{server}}}",
	{{/platforms}}
	};

	void from_json(cho::json& a_json, std::string& a_string)
	{
		a_string = a_json.to_string();
	}

	void from_json(cho::json& a_json, int64_t& a_number)
	{
		a_number = a_json.to_integer();
	}

	void from_json(cho::json& a_json, int32_t& a_number)
	{
		a_number = static_cast<int32_t>(a_json.to_integer());
	}

	void from_json(cho::json& a_json, uint64_t& a_number)
	{
		a_number = static_cast<uint64_t>(a_json.to_unsigned_integer());
	}

	void from_json(cho::json& a_json, uint32_t& a_number)
	{
		a_number = static_cast<uint32_t>(a_json.to_unsigned_integer());
	}

	void from_json(cho::json& a_json, champion_key& a_number)
	{
		a_number = static_cast<champion_key>(a_json.to_unsigned_integer());
	}

	void from_json(cho::json& a_json, double& a_number)
	{
		a_number = a_json.to_double();
	}

	void from_json(cho::json& a_json, float& a_number)
	{
		a_number = static_cast<float>(a_json.to_double());
	}

	void from_json(cho::json& a_json, bool& a_bool)
	{
		a_bool = a_json.to_bool();
	}

	template<typename T>
	void from_json(cho::json& a_json, std::vector<T>& a_array)
	{
		a_array.clear();
		T elem;
		for (auto& json_elem : a_json)
		{
			from_json(*json_elem.second, elem);
			a_array.push_back(elem);
		}
	}

	template<typename T>
	void from_json(cho::json& a_json, std::map<std::string, T>& a_map)
	{
		a_map.clear();
		T elem;
		for (auto& json_elem : a_json)
		{
			from_json(*json_elem.second, elem);
			a_map[json_elem.first.to_string()] = elem;
		}
	}

	{{#services}}
	{{#components}}
	void from_json(cho::json& a_json, {{{service}}}::{{name}}& a_element)
	{
		{{#properties}}
		if (a_json["{{json_var}}"] != nullptr)
			from_json(*a_json["{{json_var}}"], a_element.{{{name}}});
		{{/properties}}
	}

	{{/components}}
	{{/services}}
	{{#services}}
	namespace {{{service}}}
	{
		{{#methods}}
		void {{{method_name}}}_async
		(
			cho::platform_id a_platform,
			{{#params}}
			{{{type}}} a_{{{name}}},
			{{/params}}
			{{#has_optional_args}}
			{{{method_name}}}_optional_args a_optional, 
			{{/has_optional_args}}
			std::function<void(size_t response_code{{#return}}, {{{type}}} result{{/return}})> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "{{{method_name}}}";
			static const char* service = "{{{service}}}";
			
			char path[1024];
			snprintf(path, 1024, "%s{{{sprintf_path}}}", g_riot_api_servers[static_cast<int>(a_platform)]{{#path_params}}{{^has_converter}}, a_{{name}}{{/has_converter}}{{#has_converter}}, {{{converter_pre}}}a_{{name}}{{{converter_post}}}{{/has_converter}}{{/path_params}});

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				{{#return}}
				auto response_code = request->get_response_code();
				{{{type}}} return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
				{{/return}}
				{{^return}}
				a_callback(request->get_response_code());
				{{/return}}
			});
		}
		
		{{{method_name}}}_response {{{method_name}}}
		(
			cho::platform_id a_platform,
			{{#params}}
			{{{type}}} a_{{{name}}},
			{{/params}}
			{{#has_optional_args}}
			{{{method_name}}}_optional_args a_optional, 
			{{/has_optional_args}}
			riot::api* a_riot_api
		)
		{
			static const char* method = "{{{method_name}}}";
			static const char* service = "{{{service}}}";
			
			std::string path = string_format("%s{{{sprintf_path}}}", g_riot_api_servers[static_cast<int>(a_platform)]{{#path_params}}{{^has_converter}}, a_{{name}}{{/has_converter}}{{#has_converter}}, {{{converter_pre}}}a_{{name}}{{{converter_post}}}{{/has_converter}}{{/path_params}});
			{{#has_optional_args}}
			bool is_first = true;
			{{#optional_params}}
			setup_optional_argument(path, "{{{name}}}", a_optional.{{{name}}}, is_first);
			{{/optional_params}}
			{{/has_optional_args}}

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			{{{method_name}}}_response response;
			response.response_code = request->get_response_code();

			{{#return}}
			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);
			{{/return}}

			return response;
		}

		{{/methods}}
	}

	{{/services}}
}