// This file is automatically generated!
// To edit this, edit template/source.mst and run cho_generator.
#include <cho/generated/riot_api_data.hpp>
#include <cho/generated/riot_api_platform.hpp>
#include <cho/riot_api_request.hpp>
#include <cho_json/json.hpp>
#include <cho/hash.hpp>

#include <thread>

namespace cho
{
	template<typename ... Args>
	std::string string_format(const std::string& format, Args ... args)
	{
		size_t size = snprintf(nullptr, 0, format.c_str(), args ...) + 1;
		if( size <= 0 )
			throw std::runtime_error("Error during size evaluation of string_format, cannot determine end size of string!");

		if (size < 1024)
		{
			char buf[1024];
			snprintf(buf, size, format.c_str(), args...);
			return std::string(buf, buf + size - 1);
		}
		else
		{
			std::unique_ptr<char[]> buf(new char[ size ]);
			snprintf(buf.get(), size, format.c_str(), args ...);
			return std::string(buf.get(), buf.get() + size - 1);
		}
	}

	std::string to_string(const cho::champion_key& a_type)
	{
		return std::to_string(static_cast<int32_t>(a_type));
	}

	std::string to_string(const std::string& a_type)
	{
		return a_type;
	}

	template<typename T>
	void setup_optional_argument(std::string& a_path, const char* a_name, const T& a_elem, bool& a_is_first)
	{
		a_path += a_is_first ? '?' : '&';
		a_path += a_name;
		a_path += '=';
		a_path += to_string(a_elem);
		a_is_first = false;
	}

	template<typename T>
	void setup_optional_argument(std::string& a_path, const char* a_name, const std::vector<T>& a_vector, bool& a_is_first)
	{
		for (auto& elem : a_vector)
			setup_optional_argument(a_path, a_name, elem, a_is_first);
	}

	template<typename T>
	void setup_optional_argument(std::string& a_path, const char* a_name, cho::optional<T> a_elem, bool& a_is_first)
	{
		if (a_elem.filled == false)
			return;

		setup_optional_argument(a_path, a_name, a_elem.value, a_is_first);
	}

	platform_id get_platform_by_string(const char* a_platform_string)
	{
		switch (cho::crc32_lc(a_platform_string, strlen(a_platform_string)))
		{
			default:
			case COMPILE_TIME_CRC32_LC_STR("br1"): return platform_id::br1;
			case COMPILE_TIME_CRC32_LC_STR("eun1"): return platform_id::eun1;
			case COMPILE_TIME_CRC32_LC_STR("euw1"): return platform_id::euw1;
			case COMPILE_TIME_CRC32_LC_STR("jp1"): return platform_id::jp1;
			case COMPILE_TIME_CRC32_LC_STR("kr"): return platform_id::kr;
			case COMPILE_TIME_CRC32_LC_STR("la1"): return platform_id::la1;
			case COMPILE_TIME_CRC32_LC_STR("la2"): return platform_id::la2;
			case COMPILE_TIME_CRC32_LC_STR("na1"): return platform_id::na1;
			case COMPILE_TIME_CRC32_LC_STR("oc1"): return platform_id::oc1;
			case COMPILE_TIME_CRC32_LC_STR("tr1"): return platform_id::tr1;
			case COMPILE_TIME_CRC32_LC_STR("ru"): return platform_id::ru;
			case COMPILE_TIME_CRC32_LC_STR("pbe1"): return platform_id::pbe1;
			case COMPILE_TIME_CRC32_LC_STR("americas"): return platform_id::americas;
			case COMPILE_TIME_CRC32_LC_STR("europe"): return platform_id::europe;
			case COMPILE_TIME_CRC32_LC_STR("asia"): return platform_id::asia;
		}
	}

	static std::vector<const char*> g_riot_api_servers =
	{
		"https://br1.api.riotgames.com",
		"https://eun1.api.riotgames.com",
		"https://euw1.api.riotgames.com",
		"https://jp1.api.riotgames.com",
		"https://kr.api.riotgames.com",
		"https://la1.api.riotgames.com",
		"https://la2.api.riotgames.com",
		"https://na1.api.riotgames.com",
		"https://oc1.api.riotgames.com",
		"https://tr1.api.riotgames.com",
		"https://ru.api.riotgames.com",
		"https://pbe1.api.riotgames.com",
		"https://americas.api.riotgames.com",
		"https://europe.api.riotgames.com",
		"https://asia.api.riotgames.com",
	};

	void from_json(cho::json& a_json, std::string& a_string)
	{
		a_string = a_json.to_string();
	}

	void from_json(cho::json& a_json, int64_t& a_number)
	{
		a_number = a_json.to_integer();
	}

	void from_json(cho::json& a_json, int32_t& a_number)
	{
		a_number = static_cast<int32_t>(a_json.to_integer());
	}

	void from_json(cho::json& a_json, uint64_t& a_number)
	{
		a_number = static_cast<uint64_t>(a_json.to_unsigned_integer());
	}

	void from_json(cho::json& a_json, uint32_t& a_number)
	{
		a_number = static_cast<uint32_t>(a_json.to_unsigned_integer());
	}

	void from_json(cho::json& a_json, champion_key& a_number)
	{
		a_number = static_cast<champion_key>(a_json.to_unsigned_integer());
	}

	void from_json(cho::json& a_json, double& a_number)
	{
		a_number = a_json.to_double();
	}

	void from_json(cho::json& a_json, float& a_number)
	{
		a_number = static_cast<float>(a_json.to_double());
	}

	void from_json(cho::json& a_json, bool& a_bool)
	{
		a_bool = a_json.to_bool();
	}

	template<typename T>
	void from_json(cho::json& a_json, std::vector<T>& a_array)
	{
		a_array.clear();
		T elem;
		for (auto& json_elem : a_json)
		{
			from_json(*json_elem.second, elem);
			a_array.push_back(elem);
		}
	}

	template<typename T>
	void from_json(cho::json& a_json, std::map<std::string, T>& a_map)
	{
		a_map.clear();
		T elem;
		for (auto& json_elem : a_json)
		{
			from_json(*json_elem.second, elem);
			a_map[json_elem.first.to_string()] = elem;
		}
	}

	void from_json(cho::json& a_json, champion_mastery_v4::champion_mastery_dto& a_element)
	{
		if (a_json["championId"] != nullptr)
			from_json(*a_json["championId"], a_element.champion_id);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
		if (a_json["chestGranted"] != nullptr)
			from_json(*a_json["chestGranted"], a_element.chest_granted);
		if (a_json["lastPlayTime"] != nullptr)
			from_json(*a_json["lastPlayTime"], a_element.last_play_time);
		if (a_json["tokensEarned"] != nullptr)
			from_json(*a_json["tokensEarned"], a_element.tokens_earned);
		if (a_json["championLevel"] != nullptr)
			from_json(*a_json["championLevel"], a_element.champion_level);
		if (a_json["championPoints"] != nullptr)
			from_json(*a_json["championPoints"], a_element.champion_points);
		if (a_json["championPointsSinceLastLevel"] != nullptr)
			from_json(*a_json["championPointsSinceLastLevel"], a_element.champion_points_since_last_level);
		if (a_json["championPointsUntilNextLevel"] != nullptr)
			from_json(*a_json["championPointsUntilNextLevel"], a_element.champion_points_until_next_level);
	}

	void from_json(cho::json& a_json, champion_v3::champion_info& a_element)
	{
		if (a_json["freeChampionIds"] != nullptr)
			from_json(*a_json["freeChampionIds"], a_element.free_champion_ids);
		if (a_json["maxNewPlayerLevel"] != nullptr)
			from_json(*a_json["maxNewPlayerLevel"], a_element.max_new_player_level);
		if (a_json["freeChampionIdsForNewPlayers"] != nullptr)
			from_json(*a_json["freeChampionIdsForNewPlayers"], a_element.free_champion_ids_for_new_players);
	}

	void from_json(cho::json& a_json, clash_v1::player_dto& a_element)
	{
		if (a_json["role"] != nullptr)
			from_json(*a_json["role"], a_element.role);
		if (a_json["teamId"] != nullptr)
			from_json(*a_json["teamId"], a_element.team_id);
		if (a_json["position"] != nullptr)
			from_json(*a_json["position"], a_element.position);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
	}

	void from_json(cho::json& a_json, clash_v1::team_dto& a_element)
	{
		if (a_json["id"] != nullptr)
			from_json(*a_json["id"], a_element.id);
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["tier"] != nullptr)
			from_json(*a_json["tier"], a_element.tier);
		if (a_json["iconId"] != nullptr)
			from_json(*a_json["iconId"], a_element.icon_id);
		if (a_json["captain"] != nullptr)
			from_json(*a_json["captain"], a_element.captain);
		if (a_json["players"] != nullptr)
			from_json(*a_json["players"], a_element.players);
		if (a_json["abbreviation"] != nullptr)
			from_json(*a_json["abbreviation"], a_element.abbreviation);
		if (a_json["tournamentId"] != nullptr)
			from_json(*a_json["tournamentId"], a_element.tournament_id);
	}

	void from_json(cho::json& a_json, clash_v1::tournament_phase_dto& a_element)
	{
		if (a_json["id"] != nullptr)
			from_json(*a_json["id"], a_element.id);
		if (a_json["cancelled"] != nullptr)
			from_json(*a_json["cancelled"], a_element.cancelled);
		if (a_json["startTime"] != nullptr)
			from_json(*a_json["startTime"], a_element.start_time);
		if (a_json["registrationTime"] != nullptr)
			from_json(*a_json["registrationTime"], a_element.registration_time);
	}

	void from_json(cho::json& a_json, clash_v1::tournament_dto& a_element)
	{
		if (a_json["id"] != nullptr)
			from_json(*a_json["id"], a_element.id);
		if (a_json["nameKey"] != nullptr)
			from_json(*a_json["nameKey"], a_element.name_key);
		if (a_json["themeId"] != nullptr)
			from_json(*a_json["themeId"], a_element.theme_id);
		if (a_json["schedule"] != nullptr)
			from_json(*a_json["schedule"], a_element.schedule);
		if (a_json["nameKeySecondary"] != nullptr)
			from_json(*a_json["nameKeySecondary"], a_element.name_key_secondary);
	}

	void from_json(cho::json& a_json, league_exp_v4::mini_series_dto& a_element)
	{
		if (a_json["wins"] != nullptr)
			from_json(*a_json["wins"], a_element.wins);
		if (a_json["losses"] != nullptr)
			from_json(*a_json["losses"], a_element.losses);
		if (a_json["target"] != nullptr)
			from_json(*a_json["target"], a_element.target);
		if (a_json["progress"] != nullptr)
			from_json(*a_json["progress"], a_element.progress);
	}

	void from_json(cho::json& a_json, league_exp_v4::league_entry_dto& a_element)
	{
		if (a_json["rank"] != nullptr)
			from_json(*a_json["rank"], a_element.rank);
		if (a_json["tier"] != nullptr)
			from_json(*a_json["tier"], a_element.tier);
		if (a_json["wins"] != nullptr)
			from_json(*a_json["wins"], a_element.wins);
		if (a_json["losses"] != nullptr)
			from_json(*a_json["losses"], a_element.losses);
		if (a_json["veteran"] != nullptr)
			from_json(*a_json["veteran"], a_element.veteran);
		if (a_json["inactive"] != nullptr)
			from_json(*a_json["inactive"], a_element.inactive);
		if (a_json["leagueId"] != nullptr)
			from_json(*a_json["leagueId"], a_element.league_id);
		if (a_json["hotStreak"] != nullptr)
			from_json(*a_json["hotStreak"], a_element.hot_streak);
		if (a_json["queueType"] != nullptr)
			from_json(*a_json["queueType"], a_element.queue_type);
		if (a_json["freshBlood"] != nullptr)
			from_json(*a_json["freshBlood"], a_element.fresh_blood);
		if (a_json["miniSeries"] != nullptr)
			from_json(*a_json["miniSeries"], a_element.mini_series);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
		if (a_json["leaguePoints"] != nullptr)
			from_json(*a_json["leaguePoints"], a_element.league_points);
		if (a_json["summonerName"] != nullptr)
			from_json(*a_json["summonerName"], a_element.summoner_name);
	}

	void from_json(cho::json& a_json, league_v4::mini_series_dto& a_element)
	{
		if (a_json["wins"] != nullptr)
			from_json(*a_json["wins"], a_element.wins);
		if (a_json["losses"] != nullptr)
			from_json(*a_json["losses"], a_element.losses);
		if (a_json["target"] != nullptr)
			from_json(*a_json["target"], a_element.target);
		if (a_json["progress"] != nullptr)
			from_json(*a_json["progress"], a_element.progress);
	}

	void from_json(cho::json& a_json, league_v4::league_entry_dto& a_element)
	{
		if (a_json["rank"] != nullptr)
			from_json(*a_json["rank"], a_element.rank);
		if (a_json["tier"] != nullptr)
			from_json(*a_json["tier"], a_element.tier);
		if (a_json["wins"] != nullptr)
			from_json(*a_json["wins"], a_element.wins);
		if (a_json["losses"] != nullptr)
			from_json(*a_json["losses"], a_element.losses);
		if (a_json["veteran"] != nullptr)
			from_json(*a_json["veteran"], a_element.veteran);
		if (a_json["inactive"] != nullptr)
			from_json(*a_json["inactive"], a_element.inactive);
		if (a_json["leagueId"] != nullptr)
			from_json(*a_json["leagueId"], a_element.league_id);
		if (a_json["hotStreak"] != nullptr)
			from_json(*a_json["hotStreak"], a_element.hot_streak);
		if (a_json["queueType"] != nullptr)
			from_json(*a_json["queueType"], a_element.queue_type);
		if (a_json["freshBlood"] != nullptr)
			from_json(*a_json["freshBlood"], a_element.fresh_blood);
		if (a_json["miniSeries"] != nullptr)
			from_json(*a_json["miniSeries"], a_element.mini_series);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
		if (a_json["leaguePoints"] != nullptr)
			from_json(*a_json["leaguePoints"], a_element.league_points);
		if (a_json["summonerName"] != nullptr)
			from_json(*a_json["summonerName"], a_element.summoner_name);
	}

	void from_json(cho::json& a_json, league_v4::league_item_dto& a_element)
	{
		if (a_json["rank"] != nullptr)
			from_json(*a_json["rank"], a_element.rank);
		if (a_json["wins"] != nullptr)
			from_json(*a_json["wins"], a_element.wins);
		if (a_json["losses"] != nullptr)
			from_json(*a_json["losses"], a_element.losses);
		if (a_json["veteran"] != nullptr)
			from_json(*a_json["veteran"], a_element.veteran);
		if (a_json["inactive"] != nullptr)
			from_json(*a_json["inactive"], a_element.inactive);
		if (a_json["hotStreak"] != nullptr)
			from_json(*a_json["hotStreak"], a_element.hot_streak);
		if (a_json["freshBlood"] != nullptr)
			from_json(*a_json["freshBlood"], a_element.fresh_blood);
		if (a_json["miniSeries"] != nullptr)
			from_json(*a_json["miniSeries"], a_element.mini_series);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
		if (a_json["leaguePoints"] != nullptr)
			from_json(*a_json["leaguePoints"], a_element.league_points);
		if (a_json["summonerName"] != nullptr)
			from_json(*a_json["summonerName"], a_element.summoner_name);
	}

	void from_json(cho::json& a_json, league_v4::league_list_dto& a_element)
	{
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["tier"] != nullptr)
			from_json(*a_json["tier"], a_element.tier);
		if (a_json["queue"] != nullptr)
			from_json(*a_json["queue"], a_element.queue);
		if (a_json["entries"] != nullptr)
			from_json(*a_json["entries"], a_element.entries);
		if (a_json["leagueId"] != nullptr)
			from_json(*a_json["leagueId"], a_element.league_id);
	}

	void from_json(cho::json& a_json, lol_status_v3::translation& a_element)
	{
		if (a_json["locale"] != nullptr)
			from_json(*a_json["locale"], a_element.locale);
		if (a_json["content"] != nullptr)
			from_json(*a_json["content"], a_element.content);
		if (a_json["heading"] != nullptr)
			from_json(*a_json["heading"], a_element.heading);
	}

	void from_json(cho::json& a_json, lol_status_v3::message& a_element)
	{
		if (a_json["id"] != nullptr)
			from_json(*a_json["id"], a_element.id);
		if (a_json["author"] != nullptr)
			from_json(*a_json["author"], a_element.author);
		if (a_json["content"] != nullptr)
			from_json(*a_json["content"], a_element.content);
		if (a_json["severity"] != nullptr)
			from_json(*a_json["severity"], a_element.severity);
		if (a_json["created_at"] != nullptr)
			from_json(*a_json["created_at"], a_element.created_at);
		if (a_json["updated_at"] != nullptr)
			from_json(*a_json["updated_at"], a_element.updated_at);
		if (a_json["translations"] != nullptr)
			from_json(*a_json["translations"], a_element.translations);
	}

	void from_json(cho::json& a_json, lol_status_v3::incident& a_element)
	{
		if (a_json["id"] != nullptr)
			from_json(*a_json["id"], a_element.id);
		if (a_json["active"] != nullptr)
			from_json(*a_json["active"], a_element.active);
		if (a_json["updates"] != nullptr)
			from_json(*a_json["updates"], a_element.updates);
		if (a_json["created_at"] != nullptr)
			from_json(*a_json["created_at"], a_element.created_at);
	}

	void from_json(cho::json& a_json, lol_status_v3::service& a_element)
	{
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["slug"] != nullptr)
			from_json(*a_json["slug"], a_element.slug);
		if (a_json["status"] != nullptr)
			from_json(*a_json["status"], a_element.status);
		if (a_json["incidents"] != nullptr)
			from_json(*a_json["incidents"], a_element.incidents);
	}

	void from_json(cho::json& a_json, lol_status_v3::shard_status& a_element)
	{
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["slug"] != nullptr)
			from_json(*a_json["slug"], a_element.slug);
		if (a_json["locales"] != nullptr)
			from_json(*a_json["locales"], a_element.locales);
		if (a_json["hostname"] != nullptr)
			from_json(*a_json["hostname"], a_element.hostname);
		if (a_json["services"] != nullptr)
			from_json(*a_json["services"], a_element.services);
		if (a_json["region_tag"] != nullptr)
			from_json(*a_json["region_tag"], a_element.region_tag);
	}

	void from_json(cho::json& a_json, lor_ranked_v1::player_dto& a_element)
	{
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["rank"] != nullptr)
			from_json(*a_json["rank"], a_element.rank);
	}

	void from_json(cho::json& a_json, lor_ranked_v1::leaderboard_dto& a_element)
	{
		if (a_json["players"] != nullptr)
			from_json(*a_json["players"], a_element.players);
	}

	void from_json(cho::json& a_json, match_v4::mastery_dto& a_element)
	{
		if (a_json["rank"] != nullptr)
			from_json(*a_json["rank"], a_element.rank);
		if (a_json["masteryId"] != nullptr)
			from_json(*a_json["masteryId"], a_element.mastery_id);
	}

	void from_json(cho::json& a_json, match_v4::team_bans_dto& a_element)
	{
		if (a_json["pickTurn"] != nullptr)
			from_json(*a_json["pickTurn"], a_element.pick_turn);
		if (a_json["championId"] != nullptr)
			from_json(*a_json["championId"], a_element.champion_id);
	}

	void from_json(cho::json& a_json, match_v4::team_stats_dto& a_element)
	{
		if (a_json["win"] != nullptr)
			from_json(*a_json["win"], a_element.win);
		if (a_json["bans"] != nullptr)
			from_json(*a_json["bans"], a_element.bans);
		if (a_json["teamId"] != nullptr)
			from_json(*a_json["teamId"], a_element.team_id);
		if (a_json["baronKills"] != nullptr)
			from_json(*a_json["baronKills"], a_element.baron_kills);
		if (a_json["firstBaron"] != nullptr)
			from_json(*a_json["firstBaron"], a_element.first_baron);
		if (a_json["firstBlood"] != nullptr)
			from_json(*a_json["firstBlood"], a_element.first_blood);
		if (a_json["firstTower"] != nullptr)
			from_json(*a_json["firstTower"], a_element.first_tower);
		if (a_json["towerKills"] != nullptr)
			from_json(*a_json["towerKills"], a_element.tower_kills);
		if (a_json["dragonKills"] != nullptr)
			from_json(*a_json["dragonKills"], a_element.dragon_kills);
		if (a_json["firstDragon"] != nullptr)
			from_json(*a_json["firstDragon"], a_element.first_dragon);
		if (a_json["vilemawKills"] != nullptr)
			from_json(*a_json["vilemawKills"], a_element.vilemaw_kills);
		if (a_json["firstInhibitor"] != nullptr)
			from_json(*a_json["firstInhibitor"], a_element.first_inhibitor);
		if (a_json["inhibitorKills"] != nullptr)
			from_json(*a_json["inhibitorKills"], a_element.inhibitor_kills);
		if (a_json["firstRiftHerald"] != nullptr)
			from_json(*a_json["firstRiftHerald"], a_element.first_rift_herald);
		if (a_json["riftHeraldKills"] != nullptr)
			from_json(*a_json["riftHeraldKills"], a_element.rift_herald_kills);
		if (a_json["dominionVictoryScore"] != nullptr)
			from_json(*a_json["dominionVictoryScore"], a_element.dominion_victory_score);
	}

	void from_json(cho::json& a_json, match_v4::rune_dto& a_element)
	{
		if (a_json["rank"] != nullptr)
			from_json(*a_json["rank"], a_element.rank);
		if (a_json["runeId"] != nullptr)
			from_json(*a_json["runeId"], a_element.rune_id);
	}

	void from_json(cho::json& a_json, match_v4::participant_stats_dto& a_element)
	{
		if (a_json["win"] != nullptr)
			from_json(*a_json["win"], a_element.win);
		if (a_json["item0"] != nullptr)
			from_json(*a_json["item0"], a_element.item0);
		if (a_json["item1"] != nullptr)
			from_json(*a_json["item1"], a_element.item1);
		if (a_json["item2"] != nullptr)
			from_json(*a_json["item2"], a_element.item2);
		if (a_json["item3"] != nullptr)
			from_json(*a_json["item3"], a_element.item3);
		if (a_json["item4"] != nullptr)
			from_json(*a_json["item4"], a_element.item4);
		if (a_json["item5"] != nullptr)
			from_json(*a_json["item5"], a_element.item5);
		if (a_json["item6"] != nullptr)
			from_json(*a_json["item6"], a_element.item6);
		if (a_json["kills"] != nullptr)
			from_json(*a_json["kills"], a_element.kills);
		if (a_json["perk0"] != nullptr)
			from_json(*a_json["perk0"], a_element.perk0);
		if (a_json["perk1"] != nullptr)
			from_json(*a_json["perk1"], a_element.perk1);
		if (a_json["perk2"] != nullptr)
			from_json(*a_json["perk2"], a_element.perk2);
		if (a_json["perk3"] != nullptr)
			from_json(*a_json["perk3"], a_element.perk3);
		if (a_json["perk4"] != nullptr)
			from_json(*a_json["perk4"], a_element.perk4);
		if (a_json["perk5"] != nullptr)
			from_json(*a_json["perk5"], a_element.perk5);
		if (a_json["deaths"] != nullptr)
			from_json(*a_json["deaths"], a_element.deaths);
		if (a_json["assists"] != nullptr)
			from_json(*a_json["assists"], a_element.assists);
		if (a_json["goldSpent"] != nullptr)
			from_json(*a_json["goldSpent"], a_element.gold_spent);
		if (a_json["perk0Var1"] != nullptr)
			from_json(*a_json["perk0Var1"], a_element.perk0var1);
		if (a_json["perk0Var2"] != nullptr)
			from_json(*a_json["perk0Var2"], a_element.perk0var2);
		if (a_json["perk0Var3"] != nullptr)
			from_json(*a_json["perk0Var3"], a_element.perk0var3);
		if (a_json["perk1Var1"] != nullptr)
			from_json(*a_json["perk1Var1"], a_element.perk1var1);
		if (a_json["perk1Var2"] != nullptr)
			from_json(*a_json["perk1Var2"], a_element.perk1var2);
		if (a_json["perk1Var3"] != nullptr)
			from_json(*a_json["perk1Var3"], a_element.perk1var3);
		if (a_json["perk2Var1"] != nullptr)
			from_json(*a_json["perk2Var1"], a_element.perk2var1);
		if (a_json["perk2Var2"] != nullptr)
			from_json(*a_json["perk2Var2"], a_element.perk2var2);
		if (a_json["perk2Var3"] != nullptr)
			from_json(*a_json["perk2Var3"], a_element.perk2var3);
		if (a_json["perk3Var1"] != nullptr)
			from_json(*a_json["perk3Var1"], a_element.perk3var1);
		if (a_json["perk3Var2"] != nullptr)
			from_json(*a_json["perk3Var2"], a_element.perk3var2);
		if (a_json["perk3Var3"] != nullptr)
			from_json(*a_json["perk3Var3"], a_element.perk3var3);
		if (a_json["perk4Var1"] != nullptr)
			from_json(*a_json["perk4Var1"], a_element.perk4var1);
		if (a_json["perk4Var2"] != nullptr)
			from_json(*a_json["perk4Var2"], a_element.perk4var2);
		if (a_json["perk4Var3"] != nullptr)
			from_json(*a_json["perk4Var3"], a_element.perk4var3);
		if (a_json["perk5Var1"] != nullptr)
			from_json(*a_json["perk5Var1"], a_element.perk5var1);
		if (a_json["perk5Var2"] != nullptr)
			from_json(*a_json["perk5Var2"], a_element.perk5var2);
		if (a_json["perk5Var3"] != nullptr)
			from_json(*a_json["perk5Var3"], a_element.perk5var3);
		if (a_json["totalHeal"] != nullptr)
			from_json(*a_json["totalHeal"], a_element.total_heal);
		if (a_json["champLevel"] != nullptr)
			from_json(*a_json["champLevel"], a_element.champ_level);
		if (a_json["goldEarned"] != nullptr)
			from_json(*a_json["goldEarned"], a_element.gold_earned);
		if (a_json["pentaKills"] != nullptr)
			from_json(*a_json["pentaKills"], a_element.penta_kills);
		if (a_json["doubleKills"] != nullptr)
			from_json(*a_json["doubleKills"], a_element.double_kills);
		if (a_json["nodeCapture"] != nullptr)
			from_json(*a_json["nodeCapture"], a_element.node_capture);
		if (a_json["quadraKills"] != nullptr)
			from_json(*a_json["quadraKills"], a_element.quadra_kills);
		if (a_json["tripleKills"] != nullptr)
			from_json(*a_json["tripleKills"], a_element.triple_kills);
		if (a_json["turretKills"] != nullptr)
			from_json(*a_json["turretKills"], a_element.turret_kills);
		if (a_json["unrealKills"] != nullptr)
			from_json(*a_json["unrealKills"], a_element.unreal_kills);
		if (a_json["visionScore"] != nullptr)
			from_json(*a_json["visionScore"], a_element.vision_score);
		if (a_json["wardsKilled"] != nullptr)
			from_json(*a_json["wardsKilled"], a_element.wards_killed);
		if (a_json["wardsPlaced"] != nullptr)
			from_json(*a_json["wardsPlaced"], a_element.wards_placed);
		if (a_json["perkSubStyle"] != nullptr)
			from_json(*a_json["perkSubStyle"], a_element.perk_sub_style);
		if (a_json["playerScore0"] != nullptr)
			from_json(*a_json["playerScore0"], a_element.player_score0);
		if (a_json["playerScore1"] != nullptr)
			from_json(*a_json["playerScore1"], a_element.player_score1);
		if (a_json["playerScore2"] != nullptr)
			from_json(*a_json["playerScore2"], a_element.player_score2);
		if (a_json["playerScore3"] != nullptr)
			from_json(*a_json["playerScore3"], a_element.player_score3);
		if (a_json["playerScore4"] != nullptr)
			from_json(*a_json["playerScore4"], a_element.player_score4);
		if (a_json["playerScore5"] != nullptr)
			from_json(*a_json["playerScore5"], a_element.player_score5);
		if (a_json["playerScore6"] != nullptr)
			from_json(*a_json["playerScore6"], a_element.player_score6);
		if (a_json["playerScore7"] != nullptr)
			from_json(*a_json["playerScore7"], a_element.player_score7);
		if (a_json["playerScore8"] != nullptr)
			from_json(*a_json["playerScore8"], a_element.player_score8);
		if (a_json["playerScore9"] != nullptr)
			from_json(*a_json["playerScore9"], a_element.player_score9);
		if (a_json["killingSprees"] != nullptr)
			from_json(*a_json["killingSprees"], a_element.killing_sprees);
		if (a_json["participantId"] != nullptr)
			from_json(*a_json["participantId"], a_element.participant_id);
		if (a_json["teamObjective"] != nullptr)
			from_json(*a_json["teamObjective"], a_element.team_objective);
		if (a_json["altarsCaptured"] != nullptr)
			from_json(*a_json["altarsCaptured"], a_element.altars_captured);
		if (a_json["firstBloodKill"] != nullptr)
			from_json(*a_json["firstBloodKill"], a_element.first_blood_kill);
		if (a_json["firstTowerKill"] != nullptr)
			from_json(*a_json["firstTowerKill"], a_element.first_tower_kill);
		if (a_json["inhibitorKills"] != nullptr)
			from_json(*a_json["inhibitorKills"], a_element.inhibitor_kills);
		if (a_json["nodeNeutralize"] != nullptr)
			from_json(*a_json["nodeNeutralize"], a_element.node_neutralize);
		if (a_json["totalScoreRank"] != nullptr)
			from_json(*a_json["totalScoreRank"], a_element.total_score_rank);
		if (a_json["timeCCingOthers"] != nullptr)
			from_json(*a_json["timeCCingOthers"], a_element.time_ccing_others);
		if (a_json["trueDamageDealt"] != nullptr)
			from_json(*a_json["trueDamageDealt"], a_element.true_damage_dealt);
		if (a_json["trueDamageTaken"] != nullptr)
			from_json(*a_json["trueDamageTaken"], a_element.true_damage_taken);
		if (a_json["firstBloodAssist"] != nullptr)
			from_json(*a_json["firstBloodAssist"], a_element.first_blood_assist);
		if (a_json["firstTowerAssist"] != nullptr)
			from_json(*a_json["firstTowerAssist"], a_element.first_tower_assist);
		if (a_json["largestMultiKill"] != nullptr)
			from_json(*a_json["largestMultiKill"], a_element.largest_multi_kill);
		if (a_json["magicDamageDealt"] != nullptr)
			from_json(*a_json["magicDamageDealt"], a_element.magic_damage_dealt);
		if (a_json["perkPrimaryStyle"] != nullptr)
			from_json(*a_json["perkPrimaryStyle"], a_element.perk_primary_style);
		if (a_json["totalDamageDealt"] != nullptr)
			from_json(*a_json["totalDamageDealt"], a_element.total_damage_dealt);
		if (a_json["totalDamageTaken"] != nullptr)
			from_json(*a_json["totalDamageTaken"], a_element.total_damage_taken);
		if (a_json["totalPlayerScore"] != nullptr)
			from_json(*a_json["totalPlayerScore"], a_element.total_player_score);
		if (a_json["totalUnitsHealed"] != nullptr)
			from_json(*a_json["totalUnitsHealed"], a_element.total_units_healed);
		if (a_json["altarsNeutralized"] != nullptr)
			from_json(*a_json["altarsNeutralized"], a_element.altars_neutralized);
		if (a_json["combatPlayerScore"] != nullptr)
			from_json(*a_json["combatPlayerScore"], a_element.combat_player_score);
		if (a_json["nodeCaptureAssist"] != nullptr)
			from_json(*a_json["nodeCaptureAssist"], a_element.node_capture_assist);
		if (a_json["firstInhibitorKill"] != nullptr)
			from_json(*a_json["firstInhibitorKill"], a_element.first_inhibitor_kill);
		if (a_json["magicalDamageTaken"] != nullptr)
			from_json(*a_json["magicalDamageTaken"], a_element.magical_damage_taken);
		if (a_json["totalMinionsKilled"] != nullptr)
			from_json(*a_json["totalMinionsKilled"], a_element.total_minions_killed);
		if (a_json["damageSelfMitigated"] != nullptr)
			from_json(*a_json["damageSelfMitigated"], a_element.damage_self_mitigated);
		if (a_json["largestKillingSpree"] != nullptr)
			from_json(*a_json["largestKillingSpree"], a_element.largest_killing_spree);
		if (a_json["physicalDamageDealt"] != nullptr)
			from_json(*a_json["physicalDamageDealt"], a_element.physical_damage_dealt);
		if (a_json["physicalDamageTaken"] != nullptr)
			from_json(*a_json["physicalDamageTaken"], a_element.physical_damage_taken);
		if (a_json["damageDealtToTurrets"] != nullptr)
			from_json(*a_json["damageDealtToTurrets"], a_element.damage_dealt_to_turrets);
		if (a_json["firstInhibitorAssist"] != nullptr)
			from_json(*a_json["firstInhibitorAssist"], a_element.first_inhibitor_assist);
		if (a_json["neutralMinionsKilled"] != nullptr)
			from_json(*a_json["neutralMinionsKilled"], a_element.neutral_minions_killed);
		if (a_json["nodeNeutralizeAssist"] != nullptr)
			from_json(*a_json["nodeNeutralizeAssist"], a_element.node_neutralize_assist);
		if (a_json["objectivePlayerScore"] != nullptr)
			from_json(*a_json["objectivePlayerScore"], a_element.objective_player_score);
		if (a_json["largestCriticalStrike"] != nullptr)
			from_json(*a_json["largestCriticalStrike"], a_element.largest_critical_strike);
		if (a_json["longestTimeSpentLiving"] != nullptr)
			from_json(*a_json["longestTimeSpentLiving"], a_element.longest_time_spent_living);
		if (a_json["sightWardsBoughtInGame"] != nullptr)
			from_json(*a_json["sightWardsBoughtInGame"], a_element.sight_wards_bought_in_game);
		if (a_json["damageDealtToObjectives"] != nullptr)
			from_json(*a_json["damageDealtToObjectives"], a_element.damage_dealt_to_objectives);
		if (a_json["visionWardsBoughtInGame"] != nullptr)
			from_json(*a_json["visionWardsBoughtInGame"], a_element.vision_wards_bought_in_game);
		if (a_json["totalTimeCrowdControlDealt"] != nullptr)
			from_json(*a_json["totalTimeCrowdControlDealt"], a_element.total_time_crowd_control_dealt);
		if (a_json["trueDamageDealtToChampions"] != nullptr)
			from_json(*a_json["trueDamageDealtToChampions"], a_element.true_damage_dealt_to_champions);
		if (a_json["magicDamageDealtToChampions"] != nullptr)
			from_json(*a_json["magicDamageDealtToChampions"], a_element.magic_damage_dealt_to_champions);
		if (a_json["totalDamageDealtToChampions"] != nullptr)
			from_json(*a_json["totalDamageDealtToChampions"], a_element.total_damage_dealt_to_champions);
		if (a_json["neutralMinionsKilledTeamJungle"] != nullptr)
			from_json(*a_json["neutralMinionsKilledTeamJungle"], a_element.neutral_minions_killed_team_jungle);
		if (a_json["physicalDamageDealtToChampions"] != nullptr)
			from_json(*a_json["physicalDamageDealtToChampions"], a_element.physical_damage_dealt_to_champions);
		if (a_json["neutralMinionsKilledEnemyJungle"] != nullptr)
			from_json(*a_json["neutralMinionsKilledEnemyJungle"], a_element.neutral_minions_killed_enemy_jungle);
	}

	void from_json(cho::json& a_json, match_v4::participant_timeline_dto& a_element)
	{
		if (a_json["lane"] != nullptr)
			from_json(*a_json["lane"], a_element.lane);
		if (a_json["role"] != nullptr)
			from_json(*a_json["role"], a_element.role);
		if (a_json["participantId"] != nullptr)
			from_json(*a_json["participantId"], a_element.participant_id);
		if (a_json["xpPerMinDeltas"] != nullptr)
			from_json(*a_json["xpPerMinDeltas"], a_element.xp_per_min_deltas);
		if (a_json["goldPerMinDeltas"] != nullptr)
			from_json(*a_json["goldPerMinDeltas"], a_element.gold_per_min_deltas);
		if (a_json["creepsPerMinDeltas"] != nullptr)
			from_json(*a_json["creepsPerMinDeltas"], a_element.creeps_per_min_deltas);
		if (a_json["csDiffPerMinDeltas"] != nullptr)
			from_json(*a_json["csDiffPerMinDeltas"], a_element.cs_diff_per_min_deltas);
		if (a_json["xpDiffPerMinDeltas"] != nullptr)
			from_json(*a_json["xpDiffPerMinDeltas"], a_element.xp_diff_per_min_deltas);
		if (a_json["damageTakenPerMinDeltas"] != nullptr)
			from_json(*a_json["damageTakenPerMinDeltas"], a_element.damage_taken_per_min_deltas);
		if (a_json["damageTakenDiffPerMinDeltas"] != nullptr)
			from_json(*a_json["damageTakenDiffPerMinDeltas"], a_element.damage_taken_diff_per_min_deltas);
	}

	void from_json(cho::json& a_json, match_v4::participant_dto& a_element)
	{
		if (a_json["runes"] != nullptr)
			from_json(*a_json["runes"], a_element.runes);
		if (a_json["stats"] != nullptr)
			from_json(*a_json["stats"], a_element.stats);
		if (a_json["teamId"] != nullptr)
			from_json(*a_json["teamId"], a_element.team_id);
		if (a_json["spell1Id"] != nullptr)
			from_json(*a_json["spell1Id"], a_element.spell1id);
		if (a_json["spell2Id"] != nullptr)
			from_json(*a_json["spell2Id"], a_element.spell2id);
		if (a_json["timeline"] != nullptr)
			from_json(*a_json["timeline"], a_element.timeline);
		if (a_json["masteries"] != nullptr)
			from_json(*a_json["masteries"], a_element.masteries);
		if (a_json["championId"] != nullptr)
			from_json(*a_json["championId"], a_element.champion_id);
		if (a_json["participantId"] != nullptr)
			from_json(*a_json["participantId"], a_element.participant_id);
		if (a_json["highestAchievedSeasonTier"] != nullptr)
			from_json(*a_json["highestAchievedSeasonTier"], a_element.highest_achieved_season_tier);
	}

	void from_json(cho::json& a_json, match_v4::player_dto& a_element)
	{
		if (a_json["accountId"] != nullptr)
			from_json(*a_json["accountId"], a_element.account_id);
		if (a_json["platformId"] != nullptr)
			from_json(*a_json["platformId"], a_element.platform_id);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
		if (a_json["profileIcon"] != nullptr)
			from_json(*a_json["profileIcon"], a_element.profile_icon);
		if (a_json["summonerName"] != nullptr)
			from_json(*a_json["summonerName"], a_element.summoner_name);
		if (a_json["matchHistoryUri"] != nullptr)
			from_json(*a_json["matchHistoryUri"], a_element.match_history_uri);
		if (a_json["currentAccountId"] != nullptr)
			from_json(*a_json["currentAccountId"], a_element.current_account_id);
		if (a_json["currentPlatformId"] != nullptr)
			from_json(*a_json["currentPlatformId"], a_element.current_platform_id);
	}

	void from_json(cho::json& a_json, match_v4::participant_identity_dto& a_element)
	{
		if (a_json["player"] != nullptr)
			from_json(*a_json["player"], a_element.player);
		if (a_json["participantId"] != nullptr)
			from_json(*a_json["participantId"], a_element.participant_id);
	}

	void from_json(cho::json& a_json, match_v4::match_dto& a_element)
	{
		if (a_json["mapId"] != nullptr)
			from_json(*a_json["mapId"], a_element.map_id);
		if (a_json["teams"] != nullptr)
			from_json(*a_json["teams"], a_element.teams);
		if (a_json["gameId"] != nullptr)
			from_json(*a_json["gameId"], a_element.game_id);
		if (a_json["queueId"] != nullptr)
			from_json(*a_json["queueId"], a_element.queue_id);
		if (a_json["gameMode"] != nullptr)
			from_json(*a_json["gameMode"], a_element.game_mode);
		if (a_json["gameType"] != nullptr)
			from_json(*a_json["gameType"], a_element.game_type);
		if (a_json["seasonId"] != nullptr)
			from_json(*a_json["seasonId"], a_element.season_id);
		if (a_json["platformId"] != nullptr)
			from_json(*a_json["platformId"], a_element.platform_id);
		if (a_json["gameVersion"] != nullptr)
			from_json(*a_json["gameVersion"], a_element.game_version);
		if (a_json["gameCreation"] != nullptr)
			from_json(*a_json["gameCreation"], a_element.game_creation);
		if (a_json["gameDuration"] != nullptr)
			from_json(*a_json["gameDuration"], a_element.game_duration);
		if (a_json["participants"] != nullptr)
			from_json(*a_json["participants"], a_element.participants);
		if (a_json["participantIdentities"] != nullptr)
			from_json(*a_json["participantIdentities"], a_element.participant_identities);
	}

	void from_json(cho::json& a_json, match_v4::match_position_dto& a_element)
	{
		if (a_json["x"] != nullptr)
			from_json(*a_json["x"], a_element.x);
		if (a_json["y"] != nullptr)
			from_json(*a_json["y"], a_element.y);
	}

	void from_json(cho::json& a_json, match_v4::match_event_dto& a_element)
	{
		if (a_json["type"] != nullptr)
			from_json(*a_json["type"], a_element.type);
		if (a_json["itemId"] != nullptr)
			from_json(*a_json["itemId"], a_element.item_id);
		if (a_json["teamId"] != nullptr)
			from_json(*a_json["teamId"], a_element.team_id);
		if (a_json["afterId"] != nullptr)
			from_json(*a_json["afterId"], a_element.after_id);
		if (a_json["beforeId"] != nullptr)
			from_json(*a_json["beforeId"], a_element.before_id);
		if (a_json["killerId"] != nullptr)
			from_json(*a_json["killerId"], a_element.killer_id);
		if (a_json["laneType"] != nullptr)
			from_json(*a_json["laneType"], a_element.lane_type);
		if (a_json["position"] != nullptr)
			from_json(*a_json["position"], a_element.position);
		if (a_json["victimId"] != nullptr)
			from_json(*a_json["victimId"], a_element.victim_id);
		if (a_json["wardType"] != nullptr)
			from_json(*a_json["wardType"], a_element.ward_type);
		if (a_json["creatorId"] != nullptr)
			from_json(*a_json["creatorId"], a_element.creator_id);
		if (a_json["eventType"] != nullptr)
			from_json(*a_json["eventType"], a_element.event_type);
		if (a_json["skillSlot"] != nullptr)
			from_json(*a_json["skillSlot"], a_element.skill_slot);
		if (a_json["timestamp"] != nullptr)
			from_json(*a_json["timestamp"], a_element.timestamp);
		if (a_json["towerType"] != nullptr)
			from_json(*a_json["towerType"], a_element.tower_type);
		if (a_json["levelUpType"] != nullptr)
			from_json(*a_json["levelUpType"], a_element.level_up_type);
		if (a_json["monsterType"] != nullptr)
			from_json(*a_json["monsterType"], a_element.monster_type);
		if (a_json["ascendedType"] != nullptr)
			from_json(*a_json["ascendedType"], a_element.ascended_type);
		if (a_json["buildingType"] != nullptr)
			from_json(*a_json["buildingType"], a_element.building_type);
		if (a_json["participantId"] != nullptr)
			from_json(*a_json["participantId"], a_element.participant_id);
		if (a_json["pointCaptured"] != nullptr)
			from_json(*a_json["pointCaptured"], a_element.point_captured);
		if (a_json["monsterSubType"] != nullptr)
			from_json(*a_json["monsterSubType"], a_element.monster_sub_type);
		if (a_json["assistingParticipantIds"] != nullptr)
			from_json(*a_json["assistingParticipantIds"], a_element.assisting_participant_ids);
	}

	void from_json(cho::json& a_json, match_v4::match_frame_dto& a_element)
	{
		if (a_json["events"] != nullptr)
			from_json(*a_json["events"], a_element.events);
		if (a_json["timestamp"] != nullptr)
			from_json(*a_json["timestamp"], a_element.timestamp);
		if (a_json["participantFrames"] != nullptr)
			from_json(*a_json["participantFrames"], a_element.participant_frames);
	}

	void from_json(cho::json& a_json, match_v4::match_participant_frame_dto& a_element)
	{
		if (a_json["xp"] != nullptr)
			from_json(*a_json["xp"], a_element.xp);
		if (a_json["level"] != nullptr)
			from_json(*a_json["level"], a_element.level);
		if (a_json["position"] != nullptr)
			from_json(*a_json["position"], a_element.position);
		if (a_json["teamScore"] != nullptr)
			from_json(*a_json["teamScore"], a_element.team_score);
		if (a_json["totalGold"] != nullptr)
			from_json(*a_json["totalGold"], a_element.total_gold);
		if (a_json["currentGold"] != nullptr)
			from_json(*a_json["currentGold"], a_element.current_gold);
		if (a_json["dominionScore"] != nullptr)
			from_json(*a_json["dominionScore"], a_element.dominion_score);
		if (a_json["minionsKilled"] != nullptr)
			from_json(*a_json["minionsKilled"], a_element.minions_killed);
		if (a_json["participantId"] != nullptr)
			from_json(*a_json["participantId"], a_element.participant_id);
		if (a_json["jungleMinionsKilled"] != nullptr)
			from_json(*a_json["jungleMinionsKilled"], a_element.jungle_minions_killed);
	}

	void from_json(cho::json& a_json, match_v4::match_reference_dto& a_element)
	{
		if (a_json["lane"] != nullptr)
			from_json(*a_json["lane"], a_element.lane);
		if (a_json["role"] != nullptr)
			from_json(*a_json["role"], a_element.role);
		if (a_json["queue"] != nullptr)
			from_json(*a_json["queue"], a_element.queue);
		if (a_json["gameId"] != nullptr)
			from_json(*a_json["gameId"], a_element.game_id);
		if (a_json["season"] != nullptr)
			from_json(*a_json["season"], a_element.season);
		if (a_json["champion"] != nullptr)
			from_json(*a_json["champion"], a_element.champion);
		if (a_json["timestamp"] != nullptr)
			from_json(*a_json["timestamp"], a_element.timestamp);
		if (a_json["platformId"] != nullptr)
			from_json(*a_json["platformId"], a_element.platform_id);
	}

	void from_json(cho::json& a_json, match_v4::match_timeline_dto& a_element)
	{
		if (a_json["frames"] != nullptr)
			from_json(*a_json["frames"], a_element.frames);
		if (a_json["frameInterval"] != nullptr)
			from_json(*a_json["frameInterval"], a_element.frame_interval);
	}

	void from_json(cho::json& a_json, match_v4::matchlist_dto& a_element)
	{
		if (a_json["matches"] != nullptr)
			from_json(*a_json["matches"], a_element.matches);
		if (a_json["endIndex"] != nullptr)
			from_json(*a_json["endIndex"], a_element.end_index);
		if (a_json["startIndex"] != nullptr)
			from_json(*a_json["startIndex"], a_element.start_index);
		if (a_json["totalGames"] != nullptr)
			from_json(*a_json["totalGames"], a_element.total_games);
	}

	void from_json(cho::json& a_json, spectator_v4::banned_champion& a_element)
	{
		if (a_json["teamId"] != nullptr)
			from_json(*a_json["teamId"], a_element.team_id);
		if (a_json["pickTurn"] != nullptr)
			from_json(*a_json["pickTurn"], a_element.pick_turn);
		if (a_json["championId"] != nullptr)
			from_json(*a_json["championId"], a_element.champion_id);
	}

	void from_json(cho::json& a_json, spectator_v4::observer& a_element)
	{
		if (a_json["encryptionKey"] != nullptr)
			from_json(*a_json["encryptionKey"], a_element.encryption_key);
	}

	void from_json(cho::json& a_json, spectator_v4::perks& a_element)
	{
		if (a_json["perkIds"] != nullptr)
			from_json(*a_json["perkIds"], a_element.perk_ids);
		if (a_json["perkStyle"] != nullptr)
			from_json(*a_json["perkStyle"], a_element.perk_style);
		if (a_json["perkSubStyle"] != nullptr)
			from_json(*a_json["perkSubStyle"], a_element.perk_sub_style);
	}

	void from_json(cho::json& a_json, spectator_v4::game_customization_object& a_element)
	{
		if (a_json["content"] != nullptr)
			from_json(*a_json["content"], a_element.content);
		if (a_json["category"] != nullptr)
			from_json(*a_json["category"], a_element.category);
	}

	void from_json(cho::json& a_json, spectator_v4::current_game_participant& a_element)
	{
		if (a_json["bot"] != nullptr)
			from_json(*a_json["bot"], a_element.bot);
		if (a_json["perks"] != nullptr)
			from_json(*a_json["perks"], a_element.perks);
		if (a_json["teamId"] != nullptr)
			from_json(*a_json["teamId"], a_element.team_id);
		if (a_json["spell1Id"] != nullptr)
			from_json(*a_json["spell1Id"], a_element.spell1id);
		if (a_json["spell2Id"] != nullptr)
			from_json(*a_json["spell2Id"], a_element.spell2id);
		if (a_json["championId"] != nullptr)
			from_json(*a_json["championId"], a_element.champion_id);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
		if (a_json["summonerName"] != nullptr)
			from_json(*a_json["summonerName"], a_element.summoner_name);
		if (a_json["profileIconId"] != nullptr)
			from_json(*a_json["profileIconId"], a_element.profile_icon_id);
		if (a_json["gameCustomizationObjects"] != nullptr)
			from_json(*a_json["gameCustomizationObjects"], a_element.game_customization_objects);
	}

	void from_json(cho::json& a_json, spectator_v4::current_game_info& a_element)
	{
		if (a_json["mapId"] != nullptr)
			from_json(*a_json["mapId"], a_element.map_id);
		if (a_json["gameId"] != nullptr)
			from_json(*a_json["gameId"], a_element.game_id);
		if (a_json["gameMode"] != nullptr)
			from_json(*a_json["gameMode"], a_element.game_mode);
		if (a_json["gameType"] != nullptr)
			from_json(*a_json["gameType"], a_element.game_type);
		if (a_json["observers"] != nullptr)
			from_json(*a_json["observers"], a_element.observers);
		if (a_json["gameLength"] != nullptr)
			from_json(*a_json["gameLength"], a_element.game_length);
		if (a_json["platformId"] != nullptr)
			from_json(*a_json["platformId"], a_element.platform_id);
		if (a_json["participants"] != nullptr)
			from_json(*a_json["participants"], a_element.participants);
		if (a_json["gameStartTime"] != nullptr)
			from_json(*a_json["gameStartTime"], a_element.game_start_time);
		if (a_json["bannedChampions"] != nullptr)
			from_json(*a_json["bannedChampions"], a_element.banned_champions);
		if (a_json["gameQueueConfigId"] != nullptr)
			from_json(*a_json["gameQueueConfigId"], a_element.game_queue_config_id);
	}

	void from_json(cho::json& a_json, spectator_v4::participant& a_element)
	{
		if (a_json["bot"] != nullptr)
			from_json(*a_json["bot"], a_element.bot);
		if (a_json["teamId"] != nullptr)
			from_json(*a_json["teamId"], a_element.team_id);
		if (a_json["spell1Id"] != nullptr)
			from_json(*a_json["spell1Id"], a_element.spell1id);
		if (a_json["spell2Id"] != nullptr)
			from_json(*a_json["spell2Id"], a_element.spell2id);
		if (a_json["championId"] != nullptr)
			from_json(*a_json["championId"], a_element.champion_id);
		if (a_json["summonerName"] != nullptr)
			from_json(*a_json["summonerName"], a_element.summoner_name);
		if (a_json["profileIconId"] != nullptr)
			from_json(*a_json["profileIconId"], a_element.profile_icon_id);
	}

	void from_json(cho::json& a_json, spectator_v4::featured_game_info& a_element)
	{
		if (a_json["mapId"] != nullptr)
			from_json(*a_json["mapId"], a_element.map_id);
		if (a_json["gameId"] != nullptr)
			from_json(*a_json["gameId"], a_element.game_id);
		if (a_json["gameMode"] != nullptr)
			from_json(*a_json["gameMode"], a_element.game_mode);
		if (a_json["gameType"] != nullptr)
			from_json(*a_json["gameType"], a_element.game_type);
		if (a_json["observers"] != nullptr)
			from_json(*a_json["observers"], a_element.observers);
		if (a_json["gameLength"] != nullptr)
			from_json(*a_json["gameLength"], a_element.game_length);
		if (a_json["platformId"] != nullptr)
			from_json(*a_json["platformId"], a_element.platform_id);
		if (a_json["participants"] != nullptr)
			from_json(*a_json["participants"], a_element.participants);
		if (a_json["gameStartTime"] != nullptr)
			from_json(*a_json["gameStartTime"], a_element.game_start_time);
		if (a_json["bannedChampions"] != nullptr)
			from_json(*a_json["bannedChampions"], a_element.banned_champions);
		if (a_json["gameQueueConfigId"] != nullptr)
			from_json(*a_json["gameQueueConfigId"], a_element.game_queue_config_id);
	}

	void from_json(cho::json& a_json, spectator_v4::featured_games& a_element)
	{
		if (a_json["gameList"] != nullptr)
			from_json(*a_json["gameList"], a_element.game_list);
		if (a_json["clientRefreshInterval"] != nullptr)
			from_json(*a_json["clientRefreshInterval"], a_element.client_refresh_interval);
	}

	void from_json(cho::json& a_json, summoner_v4::summoner_dto& a_element)
	{
		if (a_json["id"] != nullptr)
			from_json(*a_json["id"], a_element.id);
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["puuid"] != nullptr)
			from_json(*a_json["puuid"], a_element.puuid);
		if (a_json["accountId"] != nullptr)
			from_json(*a_json["accountId"], a_element.account_id);
		if (a_json["revisionDate"] != nullptr)
			from_json(*a_json["revisionDate"], a_element.revision_date);
		if (a_json["profileIconId"] != nullptr)
			from_json(*a_json["profileIconId"], a_element.profile_icon_id);
		if (a_json["summonerLevel"] != nullptr)
			from_json(*a_json["summonerLevel"], a_element.summoner_level);
	}

	void from_json(cho::json& a_json, tft_league_v1::mini_series_dto& a_element)
	{
		if (a_json["wins"] != nullptr)
			from_json(*a_json["wins"], a_element.wins);
		if (a_json["losses"] != nullptr)
			from_json(*a_json["losses"], a_element.losses);
		if (a_json["target"] != nullptr)
			from_json(*a_json["target"], a_element.target);
		if (a_json["progress"] != nullptr)
			from_json(*a_json["progress"], a_element.progress);
	}

	void from_json(cho::json& a_json, tft_league_v1::league_entry_dto& a_element)
	{
		if (a_json["rank"] != nullptr)
			from_json(*a_json["rank"], a_element.rank);
		if (a_json["tier"] != nullptr)
			from_json(*a_json["tier"], a_element.tier);
		if (a_json["wins"] != nullptr)
			from_json(*a_json["wins"], a_element.wins);
		if (a_json["losses"] != nullptr)
			from_json(*a_json["losses"], a_element.losses);
		if (a_json["veteran"] != nullptr)
			from_json(*a_json["veteran"], a_element.veteran);
		if (a_json["inactive"] != nullptr)
			from_json(*a_json["inactive"], a_element.inactive);
		if (a_json["leagueId"] != nullptr)
			from_json(*a_json["leagueId"], a_element.league_id);
		if (a_json["hotStreak"] != nullptr)
			from_json(*a_json["hotStreak"], a_element.hot_streak);
		if (a_json["queueType"] != nullptr)
			from_json(*a_json["queueType"], a_element.queue_type);
		if (a_json["freshBlood"] != nullptr)
			from_json(*a_json["freshBlood"], a_element.fresh_blood);
		if (a_json["miniSeries"] != nullptr)
			from_json(*a_json["miniSeries"], a_element.mini_series);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
		if (a_json["leaguePoints"] != nullptr)
			from_json(*a_json["leaguePoints"], a_element.league_points);
		if (a_json["summonerName"] != nullptr)
			from_json(*a_json["summonerName"], a_element.summoner_name);
	}

	void from_json(cho::json& a_json, tft_league_v1::league_item_dto& a_element)
	{
		if (a_json["rank"] != nullptr)
			from_json(*a_json["rank"], a_element.rank);
		if (a_json["wins"] != nullptr)
			from_json(*a_json["wins"], a_element.wins);
		if (a_json["losses"] != nullptr)
			from_json(*a_json["losses"], a_element.losses);
		if (a_json["veteran"] != nullptr)
			from_json(*a_json["veteran"], a_element.veteran);
		if (a_json["inactive"] != nullptr)
			from_json(*a_json["inactive"], a_element.inactive);
		if (a_json["hotStreak"] != nullptr)
			from_json(*a_json["hotStreak"], a_element.hot_streak);
		if (a_json["freshBlood"] != nullptr)
			from_json(*a_json["freshBlood"], a_element.fresh_blood);
		if (a_json["miniSeries"] != nullptr)
			from_json(*a_json["miniSeries"], a_element.mini_series);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
		if (a_json["leaguePoints"] != nullptr)
			from_json(*a_json["leaguePoints"], a_element.league_points);
		if (a_json["summonerName"] != nullptr)
			from_json(*a_json["summonerName"], a_element.summoner_name);
	}

	void from_json(cho::json& a_json, tft_league_v1::league_list_dto& a_element)
	{
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["tier"] != nullptr)
			from_json(*a_json["tier"], a_element.tier);
		if (a_json["queue"] != nullptr)
			from_json(*a_json["queue"], a_element.queue);
		if (a_json["entries"] != nullptr)
			from_json(*a_json["entries"], a_element.entries);
		if (a_json["leagueId"] != nullptr)
			from_json(*a_json["leagueId"], a_element.league_id);
	}

	void from_json(cho::json& a_json, tft_match_v1::companion_dto& a_element)
	{
		if (a_json["skin_ID"] != nullptr)
			from_json(*a_json["skin_ID"], a_element.skin_id);
		if (a_json["species"] != nullptr)
			from_json(*a_json["species"], a_element.species);
		if (a_json["content_ID"] != nullptr)
			from_json(*a_json["content_ID"], a_element.content_id);
	}

	void from_json(cho::json& a_json, tft_match_v1::unit_dto& a_element)
	{
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["tier"] != nullptr)
			from_json(*a_json["tier"], a_element.tier);
		if (a_json["items"] != nullptr)
			from_json(*a_json["items"], a_element.items);
		if (a_json["rarity"] != nullptr)
			from_json(*a_json["rarity"], a_element.rarity);
		if (a_json["character_id"] != nullptr)
			from_json(*a_json["character_id"], a_element.character_id);
	}

	void from_json(cho::json& a_json, tft_match_v1::trait_dto& a_element)
	{
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["num_units"] != nullptr)
			from_json(*a_json["num_units"], a_element.num_units);
		if (a_json["tier_total"] != nullptr)
			from_json(*a_json["tier_total"], a_element.tier_total);
		if (a_json["tier_current"] != nullptr)
			from_json(*a_json["tier_current"], a_element.tier_current);
	}

	void from_json(cho::json& a_json, tft_match_v1::participant_dto& a_element)
	{
		if (a_json["level"] != nullptr)
			from_json(*a_json["level"], a_element.level);
		if (a_json["puuid"] != nullptr)
			from_json(*a_json["puuid"], a_element.puuid);
		if (a_json["units"] != nullptr)
			from_json(*a_json["units"], a_element.units);
		if (a_json["traits"] != nullptr)
			from_json(*a_json["traits"], a_element.traits);
		if (a_json["companion"] != nullptr)
			from_json(*a_json["companion"], a_element.companion);
		if (a_json["gold_left"] != nullptr)
			from_json(*a_json["gold_left"], a_element.gold_left);
		if (a_json["placement"] != nullptr)
			from_json(*a_json["placement"], a_element.placement);
		if (a_json["last_round"] != nullptr)
			from_json(*a_json["last_round"], a_element.last_round);
		if (a_json["time_eliminated"] != nullptr)
			from_json(*a_json["time_eliminated"], a_element.time_eliminated);
		if (a_json["players_eliminated"] != nullptr)
			from_json(*a_json["players_eliminated"], a_element.players_eliminated);
		if (a_json["total_damage_to_players"] != nullptr)
			from_json(*a_json["total_damage_to_players"], a_element.total_damage_to_players);
	}

	void from_json(cho::json& a_json, tft_match_v1::info_dto& a_element)
	{
		if (a_json["queue_id"] != nullptr)
			from_json(*a_json["queue_id"], a_element.queue_id);
		if (a_json["game_length"] != nullptr)
			from_json(*a_json["game_length"], a_element.game_length);
		if (a_json["game_version"] != nullptr)
			from_json(*a_json["game_version"], a_element.game_version);
		if (a_json["participants"] != nullptr)
			from_json(*a_json["participants"], a_element.participants);
		if (a_json["game_datetime"] != nullptr)
			from_json(*a_json["game_datetime"], a_element.game_datetime);
		if (a_json["tft_set_number"] != nullptr)
			from_json(*a_json["tft_set_number"], a_element.tft_set_number);
	}

	void from_json(cho::json& a_json, tft_match_v1::metadata_dto& a_element)
	{
		if (a_json["match_id"] != nullptr)
			from_json(*a_json["match_id"], a_element.match_id);
		if (a_json["data_version"] != nullptr)
			from_json(*a_json["data_version"], a_element.data_version);
		if (a_json["participants"] != nullptr)
			from_json(*a_json["participants"], a_element.participants);
	}

	void from_json(cho::json& a_json, tft_match_v1::match_dto& a_element)
	{
		if (a_json["info"] != nullptr)
			from_json(*a_json["info"], a_element.info);
		if (a_json["metadata"] != nullptr)
			from_json(*a_json["metadata"], a_element.metadata);
	}

	void from_json(cho::json& a_json, tft_summoner_v1::summoner_dto& a_element)
	{
		if (a_json["id"] != nullptr)
			from_json(*a_json["id"], a_element.id);
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["puuid"] != nullptr)
			from_json(*a_json["puuid"], a_element.puuid);
		if (a_json["accountId"] != nullptr)
			from_json(*a_json["accountId"], a_element.account_id);
		if (a_json["revisionDate"] != nullptr)
			from_json(*a_json["revisionDate"], a_element.revision_date);
		if (a_json["profileIconId"] != nullptr)
			from_json(*a_json["profileIconId"], a_element.profile_icon_id);
		if (a_json["summonerLevel"] != nullptr)
			from_json(*a_json["summonerLevel"], a_element.summoner_level);
	}

	void from_json(cho::json& a_json, tournament_stub_v4::lobby_event_dto& a_element)
	{
		if (a_json["eventType"] != nullptr)
			from_json(*a_json["eventType"], a_element.event_type);
		if (a_json["timestamp"] != nullptr)
			from_json(*a_json["timestamp"], a_element.timestamp);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
	}

	void from_json(cho::json& a_json, tournament_stub_v4::lobby_event_dtowrapper& a_element)
	{
		if (a_json["eventList"] != nullptr)
			from_json(*a_json["eventList"], a_element.event_list);
	}

	void from_json(cho::json& a_json, tournament_stub_v4::provider_registration_parameters& a_element)
	{
		if (a_json["url"] != nullptr)
			from_json(*a_json["url"], a_element.url);
		if (a_json["region"] != nullptr)
			from_json(*a_json["region"], a_element.region);
	}

	void from_json(cho::json& a_json, tournament_stub_v4::tournament_code_parameters& a_element)
	{
		if (a_json["mapType"] != nullptr)
			from_json(*a_json["mapType"], a_element.map_type);
		if (a_json["metadata"] != nullptr)
			from_json(*a_json["metadata"], a_element.metadata);
		if (a_json["pickType"] != nullptr)
			from_json(*a_json["pickType"], a_element.pick_type);
		if (a_json["teamSize"] != nullptr)
			from_json(*a_json["teamSize"], a_element.team_size);
		if (a_json["spectatorType"] != nullptr)
			from_json(*a_json["spectatorType"], a_element.spectator_type);
		if (a_json["allowedSummonerIds"] != nullptr)
			from_json(*a_json["allowedSummonerIds"], a_element.allowed_summoner_ids);
	}

	void from_json(cho::json& a_json, tournament_stub_v4::tournament_registration_parameters& a_element)
	{
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["providerId"] != nullptr)
			from_json(*a_json["providerId"], a_element.provider_id);
	}

	void from_json(cho::json& a_json, tournament_v4::lobby_event_dto& a_element)
	{
		if (a_json["eventType"] != nullptr)
			from_json(*a_json["eventType"], a_element.event_type);
		if (a_json["timestamp"] != nullptr)
			from_json(*a_json["timestamp"], a_element.timestamp);
		if (a_json["summonerId"] != nullptr)
			from_json(*a_json["summonerId"], a_element.summoner_id);
	}

	void from_json(cho::json& a_json, tournament_v4::lobby_event_dtowrapper& a_element)
	{
		if (a_json["eventList"] != nullptr)
			from_json(*a_json["eventList"], a_element.event_list);
	}

	void from_json(cho::json& a_json, tournament_v4::provider_registration_parameters& a_element)
	{
		if (a_json["url"] != nullptr)
			from_json(*a_json["url"], a_element.url);
		if (a_json["region"] != nullptr)
			from_json(*a_json["region"], a_element.region);
	}

	void from_json(cho::json& a_json, tournament_v4::tournament_code_dto& a_element)
	{
		if (a_json["id"] != nullptr)
			from_json(*a_json["id"], a_element.id);
		if (a_json["map"] != nullptr)
			from_json(*a_json["map"], a_element.map);
		if (a_json["code"] != nullptr)
			from_json(*a_json["code"], a_element.code);
		if (a_json["region"] != nullptr)
			from_json(*a_json["region"], a_element.region);
		if (a_json["metaData"] != nullptr)
			from_json(*a_json["metaData"], a_element.meta_data);
		if (a_json["password"] != nullptr)
			from_json(*a_json["password"], a_element.password);
		if (a_json["pickType"] != nullptr)
			from_json(*a_json["pickType"], a_element.pick_type);
		if (a_json["teamSize"] != nullptr)
			from_json(*a_json["teamSize"], a_element.team_size);
		if (a_json["lobbyName"] != nullptr)
			from_json(*a_json["lobbyName"], a_element.lobby_name);
		if (a_json["providerId"] != nullptr)
			from_json(*a_json["providerId"], a_element.provider_id);
		if (a_json["spectators"] != nullptr)
			from_json(*a_json["spectators"], a_element.spectators);
		if (a_json["participants"] != nullptr)
			from_json(*a_json["participants"], a_element.participants);
		if (a_json["tournamentId"] != nullptr)
			from_json(*a_json["tournamentId"], a_element.tournament_id);
	}

	void from_json(cho::json& a_json, tournament_v4::tournament_code_parameters& a_element)
	{
		if (a_json["mapType"] != nullptr)
			from_json(*a_json["mapType"], a_element.map_type);
		if (a_json["metadata"] != nullptr)
			from_json(*a_json["metadata"], a_element.metadata);
		if (a_json["pickType"] != nullptr)
			from_json(*a_json["pickType"], a_element.pick_type);
		if (a_json["teamSize"] != nullptr)
			from_json(*a_json["teamSize"], a_element.team_size);
		if (a_json["spectatorType"] != nullptr)
			from_json(*a_json["spectatorType"], a_element.spectator_type);
		if (a_json["allowedSummonerIds"] != nullptr)
			from_json(*a_json["allowedSummonerIds"], a_element.allowed_summoner_ids);
	}

	void from_json(cho::json& a_json, tournament_v4::tournament_code_update_parameters& a_element)
	{
		if (a_json["mapType"] != nullptr)
			from_json(*a_json["mapType"], a_element.map_type);
		if (a_json["pickType"] != nullptr)
			from_json(*a_json["pickType"], a_element.pick_type);
		if (a_json["spectatorType"] != nullptr)
			from_json(*a_json["spectatorType"], a_element.spectator_type);
		if (a_json["allowedSummonerIds"] != nullptr)
			from_json(*a_json["allowedSummonerIds"], a_element.allowed_summoner_ids);
	}

	void from_json(cho::json& a_json, tournament_v4::tournament_registration_parameters& a_element)
	{
		if (a_json["name"] != nullptr)
			from_json(*a_json["name"], a_element.name);
		if (a_json["providerId"] != nullptr)
			from_json(*a_json["providerId"], a_element.provider_id);
	}

	namespace champion_mastery_v4
	{
		void get_champion_mastery_score_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, int32_t result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_champion_mastery_score";
			static const char* service = "champion_mastery_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/champion-mastery/v4/scores/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				int32_t return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_champion_mastery_score_response get_champion_mastery_score
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_champion_mastery_score";
			static const char* service = "champion_mastery_v4";

			std::string path = string_format("%s/lol/champion-mastery/v4/scores/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_champion_mastery_score_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_all_champion_masteries_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, std::vector<champion_mastery_v4::champion_mastery_dto> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_all_champion_masteries";
			static const char* service = "champion_mastery_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/champion-mastery/v4/champion-masteries/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<champion_mastery_v4::champion_mastery_dto> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_all_champion_masteries_response get_all_champion_masteries
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_all_champion_masteries";
			static const char* service = "champion_mastery_v4";

			std::string path = string_format("%s/lol/champion-mastery/v4/champion-masteries/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_all_champion_masteries_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_champion_mastery_async
		(
			cho::platform_id a_platform,
			cho::champion_key a_champion_id,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, champion_mastery_v4::champion_mastery_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_champion_mastery";
			static const char* service = "champion_mastery_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/champion-mastery/v4/champion-masteries/by-summoner/%s/by-champion/%d", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str(), a_champion_id);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				champion_mastery_v4::champion_mastery_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_champion_mastery_response get_champion_mastery
		(
			cho::platform_id a_platform,
			cho::champion_key a_champion_id,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_champion_mastery";
			static const char* service = "champion_mastery_v4";

			std::string path = string_format("%s/lol/champion-mastery/v4/champion-masteries/by-summoner/%s/by-champion/%d", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str(), a_champion_id);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_champion_mastery_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace champion_v3
	{
		void get_champion_info_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, champion_v3::champion_info result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_champion_info";
			static const char* service = "champion_v3";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/platform/v3/champion-rotations", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				champion_v3::champion_info return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_champion_info_response get_champion_info
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_champion_info";
			static const char* service = "champion_v3";

			std::string path = string_format("%s/lol/platform/v3/champion-rotations", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_champion_info_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace clash_v1
	{
		void get_tournaments_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, std::vector<clash_v1::tournament_dto> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_tournaments";
			static const char* service = "clash_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/clash/v1/tournaments", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<clash_v1::tournament_dto> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_tournaments_response get_tournaments
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_tournaments";
			static const char* service = "clash_v1";

			std::string path = string_format("%s/lol/clash/v1/tournaments", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_tournaments_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_team_by_id_async
		(
			cho::platform_id a_platform,
			const char* a_team_id,
			std::function<void(size_t response_code, clash_v1::team_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_team_by_id";
			static const char* service = "clash_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/clash/v1/teams/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_team_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				clash_v1::team_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_team_by_id_response get_team_by_id
		(
			cho::platform_id a_platform,
			const char* a_team_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_team_by_id";
			static const char* service = "clash_v1";

			std::string path = string_format("%s/lol/clash/v1/teams/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_team_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_team_by_id_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_tournament_by_id_async
		(
			cho::platform_id a_platform,
			int32_t a_tournament_id,
			std::function<void(size_t response_code, clash_v1::tournament_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_tournament_by_id";
			static const char* service = "clash_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/clash/v1/tournaments/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_tournament_id);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				clash_v1::tournament_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_tournament_by_id_response get_tournament_by_id
		(
			cho::platform_id a_platform,
			int32_t a_tournament_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_tournament_by_id";
			static const char* service = "clash_v1";

			std::string path = string_format("%s/lol/clash/v1/tournaments/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_tournament_id);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_tournament_by_id_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_tournament_by_team_async
		(
			cho::platform_id a_platform,
			const char* a_team_id,
			std::function<void(size_t response_code, clash_v1::tournament_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_tournament_by_team";
			static const char* service = "clash_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/clash/v1/tournaments/by-team/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_team_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				clash_v1::tournament_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_tournament_by_team_response get_tournament_by_team
		(
			cho::platform_id a_platform,
			const char* a_team_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_tournament_by_team";
			static const char* service = "clash_v1";

			std::string path = string_format("%s/lol/clash/v1/tournaments/by-team/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_team_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_tournament_by_team_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_players_by_summoner_async
		(
			cho::platform_id a_platform,
			const char* a_summoner_id,
			std::function<void(size_t response_code, std::vector<clash_v1::player_dto> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_players_by_summoner";
			static const char* service = "clash_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/clash/v1/players/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<clash_v1::player_dto> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_players_by_summoner_response get_players_by_summoner
		(
			cho::platform_id a_platform,
			const char* a_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_players_by_summoner";
			static const char* service = "clash_v1";

			std::string path = string_format("%s/lol/clash/v1/players/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_players_by_summoner_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace league_exp_v4
	{
		void get_league_entries_async
		(
			cho::platform_id a_platform,
			const char* a_queue,
			const char* a_tier,
			const char* a_division,
			get_league_entries_optional_args a_optional, 
			std::function<void(size_t response_code, std::vector<league_exp_v4::league_entry_dto> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries";
			static const char* service = "league_exp_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/league-exp/v4/entries/%d/%d/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue, a_tier, a_division);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<league_exp_v4::league_entry_dto> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_league_entries_response get_league_entries
		(
			cho::platform_id a_platform,
			const char* a_queue,
			const char* a_tier,
			const char* a_division,
			get_league_entries_optional_args a_optional, 
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries";
			static const char* service = "league_exp_v4";

			std::string path = string_format("%s/lol/league-exp/v4/entries/%d/%d/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue, a_tier, a_division);
			bool is_first = true;
			setup_optional_argument(path, "page", a_optional.page, is_first);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_league_entries_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace league_v4
	{
		void get_league_by_id_async
		(
			cho::platform_id a_platform,
			const char* a_league_id,
			std::function<void(size_t response_code, league_v4::league_list_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_by_id";
			static const char* service = "league_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/league/v4/leagues/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_league_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				league_v4::league_list_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_league_by_id_response get_league_by_id
		(
			cho::platform_id a_platform,
			const char* a_league_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_by_id";
			static const char* service = "league_v4";

			std::string path = string_format("%s/lol/league/v4/leagues/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_league_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_league_by_id_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_master_league_async
		(
			cho::platform_id a_platform,
			const char* a_queue,
			std::function<void(size_t response_code, league_v4::league_list_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_master_league";
			static const char* service = "league_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/league/v4/masterleagues/by-queue/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				league_v4::league_list_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_master_league_response get_master_league
		(
			cho::platform_id a_platform,
			const char* a_queue,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_master_league";
			static const char* service = "league_v4";

			std::string path = string_format("%s/lol/league/v4/masterleagues/by-queue/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_master_league_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_league_entries_async
		(
			cho::platform_id a_platform,
			const char* a_division,
			const char* a_tier,
			const char* a_queue,
			get_league_entries_optional_args a_optional, 
			std::function<void(size_t response_code, std::vector<league_v4::league_entry_dto> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries";
			static const char* service = "league_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/league/v4/entries/%d/%d/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue, a_tier, a_division);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<league_v4::league_entry_dto> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_league_entries_response get_league_entries
		(
			cho::platform_id a_platform,
			const char* a_division,
			const char* a_tier,
			const char* a_queue,
			get_league_entries_optional_args a_optional, 
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries";
			static const char* service = "league_v4";

			std::string path = string_format("%s/lol/league/v4/entries/%d/%d/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue, a_tier, a_division);
			bool is_first = true;
			setup_optional_argument(path, "page", a_optional.page, is_first);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_league_entries_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_challenger_league_async
		(
			cho::platform_id a_platform,
			const char* a_queue,
			std::function<void(size_t response_code, league_v4::league_list_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_challenger_league";
			static const char* service = "league_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/league/v4/challengerleagues/by-queue/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				league_v4::league_list_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_challenger_league_response get_challenger_league
		(
			cho::platform_id a_platform,
			const char* a_queue,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_challenger_league";
			static const char* service = "league_v4";

			std::string path = string_format("%s/lol/league/v4/challengerleagues/by-queue/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_challenger_league_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_grandmaster_league_async
		(
			cho::platform_id a_platform,
			const char* a_queue,
			std::function<void(size_t response_code, league_v4::league_list_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_grandmaster_league";
			static const char* service = "league_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/league/v4/grandmasterleagues/by-queue/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				league_v4::league_list_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_grandmaster_league_response get_grandmaster_league
		(
			cho::platform_id a_platform,
			const char* a_queue,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_grandmaster_league";
			static const char* service = "league_v4";

			std::string path = string_format("%s/lol/league/v4/grandmasterleagues/by-queue/%d", g_riot_api_servers[static_cast<int>(a_platform)], a_queue);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_grandmaster_league_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_league_entries_for_summoner_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, std::vector<league_v4::league_entry_dto> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries_for_summoner";
			static const char* service = "league_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/league/v4/entries/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<league_v4::league_entry_dto> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_league_entries_for_summoner_response get_league_entries_for_summoner
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries_for_summoner";
			static const char* service = "league_v4";

			std::string path = string_format("%s/lol/league/v4/entries/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_league_entries_for_summoner_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace lol_status_v3
	{
		void get_shard_data_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, lol_status_v3::shard_status result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_shard_data";
			static const char* service = "lol_status_v3";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/status/v3/shard-data", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				lol_status_v3::shard_status return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_shard_data_response get_shard_data
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_shard_data";
			static const char* service = "lol_status_v3";

			std::string path = string_format("%s/lol/status/v3/shard-data", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_shard_data_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace lor_ranked_v1
	{
		void get_leaderboards_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, lor_ranked_v1::leaderboard_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_leaderboards";
			static const char* service = "lor_ranked_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/lor/ranked/v1/leaderboards", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				lor_ranked_v1::leaderboard_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_leaderboards_response get_leaderboards
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_leaderboards";
			static const char* service = "lor_ranked_v1";

			std::string path = string_format("%s/lor/ranked/v1/leaderboards", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_leaderboards_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace match_v4
	{
		void get_match_async
		(
			cho::platform_id a_platform,
			int64_t a_match_id,
			std::function<void(size_t response_code, match_v4::match_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match";
			static const char* service = "match_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/match/v4/matches/%lld", g_riot_api_servers[static_cast<int>(a_platform)], a_match_id);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				match_v4::match_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_match_response get_match
		(
			cho::platform_id a_platform,
			int64_t a_match_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match";
			static const char* service = "match_v4";

			std::string path = string_format("%s/lol/match/v4/matches/%lld", g_riot_api_servers[static_cast<int>(a_platform)], a_match_id);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_match_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_match_timeline_async
		(
			cho::platform_id a_platform,
			int64_t a_match_id,
			std::function<void(size_t response_code, match_v4::match_timeline_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match_timeline";
			static const char* service = "match_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/match/v4/timelines/by-match/%lld", g_riot_api_servers[static_cast<int>(a_platform)], a_match_id);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				match_v4::match_timeline_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_match_timeline_response get_match_timeline
		(
			cho::platform_id a_platform,
			int64_t a_match_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match_timeline";
			static const char* service = "match_v4";

			std::string path = string_format("%s/lol/match/v4/timelines/by-match/%lld", g_riot_api_servers[static_cast<int>(a_platform)], a_match_id);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_match_timeline_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_matchlist_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			get_matchlist_optional_args a_optional, 
			std::function<void(size_t response_code, match_v4::matchlist_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_matchlist";
			static const char* service = "match_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/match/v4/matchlists/by-account/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_account_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				match_v4::matchlist_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_matchlist_response get_matchlist
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			get_matchlist_optional_args a_optional, 
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_matchlist";
			static const char* service = "match_v4";

			std::string path = string_format("%s/lol/match/v4/matchlists/by-account/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_account_id).c_str());
			bool is_first = true;
			setup_optional_argument(path, "champion", a_optional.champion, is_first);
			setup_optional_argument(path, "queue", a_optional.queue, is_first);
			setup_optional_argument(path, "season", a_optional.season, is_first);
			setup_optional_argument(path, "end_time", a_optional.end_time, is_first);
			setup_optional_argument(path, "begin_time", a_optional.begin_time, is_first);
			setup_optional_argument(path, "end_index", a_optional.end_index, is_first);
			setup_optional_argument(path, "begin_index", a_optional.begin_index, is_first);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_matchlist_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_match_ids_by_tournament_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code, std::vector<int64_t> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match_ids_by_tournament_code";
			static const char* service = "match_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/match/v4/matches/by-tournament-code/%s/ids", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<int64_t> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_match_ids_by_tournament_code_response get_match_ids_by_tournament_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match_ids_by_tournament_code";
			static const char* service = "match_v4";

			std::string path = string_format("%s/lol/match/v4/matches/by-tournament-code/%s/ids", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_match_ids_by_tournament_code_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_match_by_tournament_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			int64_t a_match_id,
			std::function<void(size_t response_code, match_v4::match_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match_by_tournament_code";
			static const char* service = "match_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/match/v4/matches/%lld/by-tournament-code/%s", g_riot_api_servers[static_cast<int>(a_platform)], a_match_id, cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				match_v4::match_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_match_by_tournament_code_response get_match_by_tournament_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			int64_t a_match_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match_by_tournament_code";
			static const char* service = "match_v4";

			std::string path = string_format("%s/lol/match/v4/matches/%lld/by-tournament-code/%s", g_riot_api_servers[static_cast<int>(a_platform)], a_match_id, cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_match_by_tournament_code_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace spectator_v4
	{
		void get_featured_games_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, spectator_v4::featured_games result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_featured_games";
			static const char* service = "spectator_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/spectator/v4/featured-games", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				spectator_v4::featured_games return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_featured_games_response get_featured_games
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_featured_games";
			static const char* service = "spectator_v4";

			std::string path = string_format("%s/lol/spectator/v4/featured-games", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_featured_games_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_current_game_info_by_summoner_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, spectator_v4::current_game_info result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_current_game_info_by_summoner";
			static const char* service = "spectator_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/spectator/v4/active-games/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				spectator_v4::current_game_info return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_current_game_info_by_summoner_response get_current_game_info_by_summoner
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_current_game_info_by_summoner";
			static const char* service = "spectator_v4";

			std::string path = string_format("%s/lol/spectator/v4/active-games/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_current_game_info_by_summoner_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace summoner_v4
	{
		void get_by_summoner_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, summoner_v4::summoner_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_summoner_id";
			static const char* service = "summoner_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/summoner/v4/summoners/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				summoner_v4::summoner_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_by_summoner_id_response get_by_summoner_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_summoner_id";
			static const char* service = "summoner_v4";

			std::string path = string_format("%s/lol/summoner/v4/summoners/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_by_summoner_id_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_by_summoner_name_async
		(
			cho::platform_id a_platform,
			const char* a_summoner_name,
			std::function<void(size_t response_code, summoner_v4::summoner_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_summoner_name";
			static const char* service = "summoner_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/summoner/v4/summoners/by-name/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_summoner_name).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				summoner_v4::summoner_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_by_summoner_name_response get_by_summoner_name
		(
			cho::platform_id a_platform,
			const char* a_summoner_name,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_summoner_name";
			static const char* service = "summoner_v4";

			std::string path = string_format("%s/lol/summoner/v4/summoners/by-name/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_summoner_name).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_by_summoner_name_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_by_puuid_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_puuid,
			std::function<void(size_t response_code, summoner_v4::summoner_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_puuid";
			static const char* service = "summoner_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/summoner/v4/summoners/by-puuid/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_puuid).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				summoner_v4::summoner_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_by_puuid_response get_by_puuid
		(
			cho::platform_id a_platform,
			const char* a_encrypted_puuid,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_puuid";
			static const char* service = "summoner_v4";

			std::string path = string_format("%s/lol/summoner/v4/summoners/by-puuid/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_puuid).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_by_puuid_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_by_account_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			std::function<void(size_t response_code, summoner_v4::summoner_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_account_id";
			static const char* service = "summoner_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/summoner/v4/summoners/by-account/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_account_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				summoner_v4::summoner_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_by_account_id_response get_by_account_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_account_id";
			static const char* service = "summoner_v4";

			std::string path = string_format("%s/lol/summoner/v4/summoners/by-account/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_account_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_by_account_id_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace tft_league_v1
	{
		void get_master_league_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, tft_league_v1::league_list_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_master_league";
			static const char* service = "tft_league_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/league/v1/master", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tft_league_v1::league_list_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_master_league_response get_master_league
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_master_league";
			static const char* service = "tft_league_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/league/v1/master", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_master_league_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_challenger_league_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, tft_league_v1::league_list_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_challenger_league";
			static const char* service = "tft_league_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/league/v1/challenger", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tft_league_v1::league_list_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_challenger_league_response get_challenger_league
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_challenger_league";
			static const char* service = "tft_league_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/league/v1/challenger", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_challenger_league_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_grandmaster_league_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, tft_league_v1::league_list_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_grandmaster_league";
			static const char* service = "tft_league_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/league/v1/grandmaster", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tft_league_v1::league_list_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_grandmaster_league_response get_grandmaster_league
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_grandmaster_league";
			static const char* service = "tft_league_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/league/v1/grandmaster", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_grandmaster_league_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_league_by_id_async
		(
			cho::platform_id a_platform,
			const char* a_league_id,
			std::function<void(size_t response_code, tft_league_v1::league_list_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_by_id";
			static const char* service = "tft_league_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/league/v1/leagues/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_league_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tft_league_v1::league_list_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_league_by_id_response get_league_by_id
		(
			cho::platform_id a_platform,
			const char* a_league_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_by_id";
			static const char* service = "tft_league_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/league/v1/leagues/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_league_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_league_by_id_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_league_entries_async
		(
			cho::platform_id a_platform,
			const char* a_tier,
			const char* a_division,
			get_league_entries_optional_args a_optional, 
			std::function<void(size_t response_code, std::vector<tft_league_v1::league_entry_dto> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries";
			static const char* service = "tft_league_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/league/v1/entries/%s/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tier).c_str(), cho::request::url_encode(a_division).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<tft_league_v1::league_entry_dto> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_league_entries_response get_league_entries
		(
			cho::platform_id a_platform,
			const char* a_tier,
			const char* a_division,
			get_league_entries_optional_args a_optional, 
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries";
			static const char* service = "tft_league_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/league/v1/entries/%s/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tier).c_str(), cho::request::url_encode(a_division).c_str());
			bool is_first = true;
			setup_optional_argument(path, "page", a_optional.page, is_first);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_league_entries_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_league_entries_for_summoner_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, std::vector<tft_league_v1::league_entry_dto> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries_for_summoner";
			static const char* service = "tft_league_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/league/v1/entries/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<tft_league_v1::league_entry_dto> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_league_entries_for_summoner_response get_league_entries_for_summoner
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_league_entries_for_summoner";
			static const char* service = "tft_league_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/league/v1/entries/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_league_entries_for_summoner_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace tft_match_v1
	{
		void get_match_async
		(
			cho::platform_id a_platform,
			const char* a_match_id,
			std::function<void(size_t response_code, tft_match_v1::match_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match";
			static const char* service = "tft_match_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/match/v1/matches/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_match_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tft_match_v1::match_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_match_response get_match
		(
			cho::platform_id a_platform,
			const char* a_match_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match";
			static const char* service = "tft_match_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/match/v1/matches/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_match_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_match_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_match_ids_by_puuid_async
		(
			cho::platform_id a_platform,
			const char* a_puuid,
			get_match_ids_by_puuid_optional_args a_optional, 
			std::function<void(size_t response_code, std::vector<std::string> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match_ids_by_puuid";
			static const char* service = "tft_match_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/match/v1/matches/by-puuid/%s/ids", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_puuid).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<std::string> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_match_ids_by_puuid_response get_match_ids_by_puuid
		(
			cho::platform_id a_platform,
			const char* a_puuid,
			get_match_ids_by_puuid_optional_args a_optional, 
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_match_ids_by_puuid";
			static const char* service = "tft_match_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/match/v1/matches/by-puuid/%s/ids", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_puuid).c_str());
			bool is_first = true;
			setup_optional_argument(path, "count", a_optional.count, is_first);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_match_ids_by_puuid_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace tft_summoner_v1
	{
		void get_by_summoner_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, tft_summoner_v1::summoner_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_summoner_id";
			static const char* service = "tft_summoner_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/summoner/v1/summoners/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tft_summoner_v1::summoner_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_by_summoner_id_response get_by_summoner_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_summoner_id";
			static const char* service = "tft_summoner_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/summoner/v1/summoners/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_by_summoner_id_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_by_summoner_name_async
		(
			cho::platform_id a_platform,
			const char* a_summoner_name,
			std::function<void(size_t response_code, tft_summoner_v1::summoner_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_summoner_name";
			static const char* service = "tft_summoner_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/summoner/v1/summoners/by-name/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_summoner_name).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tft_summoner_v1::summoner_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_by_summoner_name_response get_by_summoner_name
		(
			cho::platform_id a_platform,
			const char* a_summoner_name,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_summoner_name";
			static const char* service = "tft_summoner_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/summoner/v1/summoners/by-name/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_summoner_name).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_by_summoner_name_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_by_puuid_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_puuid,
			std::function<void(size_t response_code, tft_summoner_v1::summoner_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_puuid";
			static const char* service = "tft_summoner_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/summoner/v1/summoners/by-puuid/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_puuid).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tft_summoner_v1::summoner_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_by_puuid_response get_by_puuid
		(
			cho::platform_id a_platform,
			const char* a_encrypted_puuid,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_puuid";
			static const char* service = "tft_summoner_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/summoner/v1/summoners/by-puuid/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_puuid).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_by_puuid_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_by_account_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			std::function<void(size_t response_code, tft_summoner_v1::summoner_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_account_id";
			static const char* service = "tft_summoner_v1";
			
			char path[1024];
			snprintf(path, 1024, "%s/tft/summoner/v1/summoners/by-account/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_account_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tft_summoner_v1::summoner_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_by_account_id_response get_by_account_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_by_account_id";
			static const char* service = "tft_summoner_v1";

			switch (a_platform)
			{
			case cho::platform_id::eun1:
			case cho::platform_id::euw1:
			case cho::platform_id::tr1:
			case cho::platform_id::ru:
				a_platform = cho::platform_id::europe;
				break;

			case cho::platform_id::jp1:
			case cho::platform_id::kr:
				a_platform = cho::platform_id::asia;
				break;

			case cho::platform_id::la1:
			case cho::platform_id::la2:
			case cho::platform_id::na1:
			case cho::platform_id::oc1:
			case cho::platform_id::pbe1:
			case cho::platform_id::br1:
				a_platform = cho::platform_id::americas;
				break;
			}

			std::string path = string_format("%s/tft/summoner/v1/summoners/by-account/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_account_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_by_account_id_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace third_party_code_v4
	{
		void get_third_party_code_by_summoner_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, std::string result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_third_party_code_by_summoner_id";
			static const char* service = "third_party_code_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/platform/v4/third-party-code/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::string return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_third_party_code_by_summoner_id_response get_third_party_code_by_summoner_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_third_party_code_by_summoner_id";
			static const char* service = "third_party_code_v4";

			std::string path = string_format("%s/lol/platform/v4/third-party-code/by-summoner/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_encrypted_summoner_id).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_third_party_code_by_summoner_id_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace tournament_stub_v4
	{
		void create_tournament_code_async
		(
			cho::platform_id a_platform,
			int64_t a_tournament_id,
			create_tournament_code_optional_args a_optional, 
			std::function<void(size_t response_code, std::vector<std::string> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "create_tournament_code";
			static const char* service = "tournament_stub_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament-stub/v4/codes", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<std::string> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		create_tournament_code_response create_tournament_code
		(
			cho::platform_id a_platform,
			int64_t a_tournament_id,
			create_tournament_code_optional_args a_optional, 
			riot::api* a_riot_api
		)
		{
			static const char* method = "create_tournament_code";
			static const char* service = "tournament_stub_v4";

			std::string path = string_format("%s/lol/tournament-stub/v4/codes", g_riot_api_servers[static_cast<int>(a_platform)]);
			bool is_first = true;
			setup_optional_argument(path, "count", a_optional.count, is_first);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			create_tournament_code_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void register_provider_data_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, int32_t result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "register_provider_data";
			static const char* service = "tournament_stub_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament-stub/v4/providers", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				int32_t return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		register_provider_data_response register_provider_data
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "register_provider_data";
			static const char* service = "tournament_stub_v4";

			std::string path = string_format("%s/lol/tournament-stub/v4/providers", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			register_provider_data_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void register_tournament_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, int32_t result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "register_tournament";
			static const char* service = "tournament_stub_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament-stub/v4/tournaments", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				int32_t return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		register_tournament_response register_tournament
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "register_tournament";
			static const char* service = "tournament_stub_v4";

			std::string path = string_format("%s/lol/tournament-stub/v4/tournaments", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			register_tournament_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_lobby_events_by_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code, tournament_stub_v4::lobby_event_dtowrapper result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_lobby_events_by_code";
			static const char* service = "tournament_stub_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament-stub/v4/lobby-events/by-code/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tournament_stub_v4::lobby_event_dtowrapper return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_lobby_events_by_code_response get_lobby_events_by_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_lobby_events_by_code";
			static const char* service = "tournament_stub_v4";

			std::string path = string_format("%s/lol/tournament-stub/v4/lobby-events/by-code/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_lobby_events_by_code_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

	namespace tournament_v4
	{
		void create_tournament_code_async
		(
			cho::platform_id a_platform,
			int64_t a_tournament_id,
			create_tournament_code_optional_args a_optional, 
			std::function<void(size_t response_code, std::vector<std::string> result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "create_tournament_code";
			static const char* service = "tournament_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament/v4/codes", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				std::vector<std::string> return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		create_tournament_code_response create_tournament_code
		(
			cho::platform_id a_platform,
			int64_t a_tournament_id,
			create_tournament_code_optional_args a_optional, 
			riot::api* a_riot_api
		)
		{
			static const char* method = "create_tournament_code";
			static const char* service = "tournament_v4";

			std::string path = string_format("%s/lol/tournament/v4/codes", g_riot_api_servers[static_cast<int>(a_platform)]);
			bool is_first = true;
			setup_optional_argument(path, "count", a_optional.count, is_first);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			create_tournament_code_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void register_provider_data_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, int32_t result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "register_provider_data";
			static const char* service = "tournament_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament/v4/providers", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				int32_t return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		register_provider_data_response register_provider_data
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "register_provider_data";
			static const char* service = "tournament_v4";

			std::string path = string_format("%s/lol/tournament/v4/providers", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			register_provider_data_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void register_tournament_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, int32_t result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "register_tournament";
			static const char* service = "tournament_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament/v4/tournaments", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				int32_t return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		register_tournament_response register_tournament
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api
		)
		{
			static const char* method = "register_tournament";
			static const char* service = "tournament_v4";

			std::string path = string_format("%s/lol/tournament/v4/tournaments", g_riot_api_servers[static_cast<int>(a_platform)]);

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			register_tournament_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void get_tournament_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code, tournament_v4::tournament_code_dto result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_tournament_code";
			static const char* service = "tournament_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament/v4/codes/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tournament_v4::tournament_code_dto return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_tournament_code_response get_tournament_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_tournament_code";
			static const char* service = "tournament_v4";

			std::string path = string_format("%s/lol/tournament/v4/codes/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_tournament_code_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

		void update_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "update_code";
			static const char* service = "tournament_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament/v4/codes/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				a_callback(request->get_response_code());
			});
		}
		
		update_code_response update_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api
		)
		{
			static const char* method = "update_code";
			static const char* service = "tournament_v4";

			std::string path = string_format("%s/lol/tournament/v4/codes/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			update_code_response response;
			response.response_code = request->get_response_code();


			return response;
		}

		void get_lobby_events_by_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code, tournament_v4::lobby_event_dtowrapper result)> a_callback,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_lobby_events_by_code";
			static const char* service = "tournament_v4";
			
			char path[1024];
			snprintf(path, 1024, "%s/lol/tournament/v4/lobby-events/by-code/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path);

			std::async(std::launch::async, [&request, a_callback]()
			{
				request->perform();

				if (!a_callback) // If no callback was supplied, we don't parse the json result.
					return;

				auto response_code = request->get_response_code();
				tournament_v4::lobby_event_dtowrapper return_element;
				if (response_code >= 200 && response_code < 300)
					from_json(request->get_json(), return_element);
				a_callback(response_code, return_element);
			});
		}
		
		get_lobby_events_by_code_response get_lobby_events_by_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api
		)
		{
			static const char* method = "get_lobby_events_by_code";
			static const char* service = "tournament_v4";

			std::string path = string_format("%s/lol/tournament/v4/lobby-events/by-code/%s", g_riot_api_servers[static_cast<int>(a_platform)], cho::request::url_encode(a_tournament_code).c_str());

			auto request = a_riot_api->make_request(a_platform, service, method, path.c_str());

			request->perform();

			get_lobby_events_by_code_response response;
			response.response_code = request->get_response_code();

			if (response.response_code >= 200 && response.response_code < 300)
				from_json(request->get_json(), response.result);

			return response;
		}

	}

}