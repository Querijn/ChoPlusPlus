#pragma once
// This file is automatically generated!
// To edit this, edit template/header.mst and run cho_generator.

{{#std_includes}}
#include <{{{this}}}>
{{/std_includes}}
#include <functional>
#include <string>
#include <map>
#include <set>

#include <cho/riot_api.hpp>
#include <cho/optional.hpp>
#include <cho/generated/riot_api_platform.hpp>

namespace cho
{
	enum class champion_key
	{
	{{#champions}}
		{{id}} = {{key}},
	{{/champions}}
	};

	{{#services}}
	namespace {{{service}}}
	{
		{{#components}}
		struct {{name}};
		{{/components}}
	}

	{{/services}}
	{{#services}}
	namespace {{{service}}}
	{
		{{#components}}
		struct {{name}}
		{
			{{#properties}}
			{{{type}}} {{{name}}};
			{{/properties}}
		};

		{{/components}}
		{{#methods}}
		{{#has_optional_args}}
		/*
			Optional arguments for {{{method_name}}}
		*/
		struct {{{method_name}}}_optional_args
		{
			{{#optional_params}}
			{{{type}}} {{{name}}};
			{{/optional_params}}
		};
		{{/has_optional_args}}
		/* 
			Description: {{description}} This method is async, running on a separate thread.
			Docs: {{{docs}}}
			Path: {{{path}}}
		*/
		void {{{method_name}}}_async
		(
			cho::platform_id a_platform,
			{{#params}}
			{{{type}}} a_{{{name}}},
			{{/params}}
			{{#has_optional_args}}
			{{{method_name}}}_optional_args a_optional = {{{method_name}}}_optional_args(), 
			{{/has_optional_args}}
			std::function<void(size_t response_code{{#return}}, {{{type}}} result{{/return}})> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct {{{method_name}}}_response
		{
			size_t response_code;
			{{#return}}{{{type}}} result;{{/return}}
		};

		/* 
			Description: {{description}}
			Docs: {{{docs}}}
			Path: {{{path}}}
		*/
		{{{method_name}}}_response {{{method_name}}}
		(
			cho::platform_id a_platform,
			{{#params}}
			{{{type}}} a_{{{name}}},
			{{/params}}
			{{#has_optional_args}}
			{{{method_name}}}_optional_args a_optional = {{{method_name}}}_optional_args(), 
			{{/has_optional_args}}
			riot::api* a_riot_api = riot::api::get_global()
		);

		{{/methods}}
	}

	{{/services}}
	template<typename serialiser, typename type>
	void serialise(serialiser& a_serialiser, const char* a_name, type& a_type)
	{
		a_serialiser.serialise(a_name, a_type);
	}

	template<typename serialiser, typename type>
	void serialise(serialiser& a_serialiser, const char* a_name, std::vector<type>& a_array)
	{
		a_serialiser.on_array_enter(a_name, a_array);

		for (size_t i = 0; i < a_array.size(); i++)
		{
			auto str = std::to_string(i);
			serialise(a_serialiser, str.c_str(), a_array[i]);
		}
		
		a_serialiser.on_array_exit();
	}

	template<typename serialiser, typename type>
	void serialise(serialiser& a_serialiser, const char* a_name, std::set<type>& a_array)
	{
		a_serialiser.on_array_enter(a_name, a_array);

		for (size_t i = 0; i < a_array.size(); i++)
		{
			auto str = std::to_string(i);
			serialise(a_serialiser, str.c_str(), a_array[i]);
		}

		a_serialiser.on_array_exit();
	}
	
	template<typename T>
	std::string to_string(const T& a_type)
	{
		return std::to_string(a_type);
	}

	std::string to_string(const cho::champion_key& a_type);
	std::string to_string(const std::string& a_type);

	template<typename serialiser, typename key, typename value>
	void serialise(serialiser& a_serialiser, const char* a_name, std::map<key, value>& a_map)
	{
		a_serialiser.on_map_enter(a_name, a_map);

		for (auto& elem : a_map)
		{
			auto str = cho::to_string(elem.first);
			serialise(a_serialiser, str.c_str(), elem.second);
		}
		
		a_serialiser.on_map_exit();
	}
	{{#services}}
	{{#components}}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, {{{service}}}::{{name}}& a_{{name}})
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_{{name}};
		{{#properties}}
		serialise(a_serialiser, "{{{name}}}", parent.{{{name}}});
		{{/properties}}

		a_serialiser.on_struct_exit();
	}
	{{/components}}
	{{/services}}
}