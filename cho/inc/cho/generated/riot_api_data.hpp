#pragma once
// This file is automatically generated!
// To edit this, edit template/header.mst and run cho_generator.

#include <functional>
#include <string>
#include <map>
#include <set>

#include <cho/riot_api.hpp>
#include <cho/optional.hpp>
#include <cho/generated/riot_api_platform.hpp>

namespace cho
{
	enum class champion_key
	{
		Vi = 254,
		Jax = 24,
		Lux = 99,
		Zac = 154,
		Zed = 238,
		Zoe = 142,
		Ahri = 103,
		Ashe = 22,
		Azir = 268,
		Bard = 432,
		Ekko = 245,
		Fizz = 105,
		Gnar = 150,
		Jhin = 202,
		Jinx = 222,
		Kayn = 141,
		Kled = 240,
		Lulu = 117,
		Nami = 267,
		Nunu = 20,
		Olaf = 2,
		Ornn = 516,
		Pyke = 555,
		Ryze = 13,
		Sett = 875,
		Shen = 98,
		Sion = 14,
		Sona = 37,
		Udyr = 77,
		Zyra = 143,
		Akali = 84,
		Amumu = 32,
		Annie = 1,
		Brand = 63,
		Braum = 201,
		Corki = 42,
		Diana = 131,
		Elise = 60,
		Fiora = 114,
		Galio = 3,
		Garen = 86,
		Ivern = 427,
		Janna = 40,
		Jayce = 126,
		Kaisa = 145,
		Karma = 43,
		Kayle = 10,
		Leona = 89,
		Nasus = 75,
		Neeko = 518,
		Poppy = 78,
		Quinn = 133,
		Rakan = 497,
		Riven = 92,
		Senna = 235,
		Shaco = 35,
		Sivir = 15,
		Swain = 50,
		Sylas = 517,
		Talon = 91,
		Taric = 44,
		Teemo = 17,
		Urgot = 6,
		Varus = 110,
		Vayne = 67,
		Xayah = 498,
		Yasuo = 157,
		Yuumi = 350,
		Ziggs = 115,
		Aatrox = 266,
		Anivia = 34,
		Darius = 122,
		Draven = 119,
		Ezreal = 81,
		Gragas = 79,
		Graves = 104,
		Illaoi = 420,
		Irelia = 39,
		Kennen = 85,
		Khazix = 121,
		KogMaw = 96,
		LeeSin = 64,
		Lucian = 236,
		Maokai = 57,
		Qiyana = 246,
		Rammus = 33,
		RekSai = 421,
		Rengar = 107,
		Rumble = 68,
		Singed = 27,
		Soraka = 16,
		Syndra = 134,
		Thresh = 412,
		Twitch = 29,
		Veigar = 45,
		Velkoz = 161,
		Viktor = 112,
		Xerath = 101,
		Yorick = 83,
		Zilean = 26,
		Alistar = 12,
		Caitlyn = 51,
		Camille = 164,
		Chogath = 31,
		DrMundo = 36,
		Evelynn = 28,
		Hecarim = 120,
		Kalista = 429,
		Karthus = 30,
		Kindred = 203,
		Leblanc = 7,
		Morgana = 25,
		Nidalee = 76,
		Orianna = 61,
		Sejuani = 113,
		Shyvana = 102,
		Skarner = 72,
		Taliyah = 163,
		Trundle = 48,
		Warwick = 19,
		XinZhao = 5,
		Aphelios = 523,
		JarvanIV = 59,
		Kassadin = 38,
		Katarina = 55,
		Malphite = 54,
		Malzahar = 90,
		MasterYi = 11,
		Nautilus = 111,
		Nocturne = 56,
		Pantheon = 80,
		Renekton = 58,
		Tristana = 18,
		Vladimir = 8,
		Volibear = 106,
		Gangplank = 41,
		Lissandra = 127,
		TahmKench = 223,
		Blitzcrank = 53,
		Cassiopeia = 69,
		MonkeyKing = 62,
		Tryndamere = 23,
		AurelionSol = 136,
		MissFortune = 21,
		Mordekaiser = 82,
		TwistedFate = 4,
		Fiddlesticks = 9,
		Heimerdinger = 74,
	};

	namespace champion_mastery_v4
	{
		struct champion_mastery_dto;
	}

	namespace champion_v3
	{
		struct champion_info;
	}

	namespace clash_v1
	{
		struct player_dto;
		struct team_dto;
		struct tournament_phase_dto;
		struct tournament_dto;
	}

	namespace league_exp_v4
	{
		struct mini_series_dto;
		struct league_entry_dto;
	}

	namespace league_v4
	{
		struct mini_series_dto;
		struct league_entry_dto;
		struct league_item_dto;
		struct league_list_dto;
	}

	namespace lol_status_v3
	{
		struct translation;
		struct message;
		struct incident;
		struct service;
		struct shard_status;
	}

	namespace lor_ranked_v1
	{
		struct player_dto;
		struct leaderboard_dto;
	}

	namespace match_v4
	{
		struct mastery_dto;
		struct team_bans_dto;
		struct team_stats_dto;
		struct rune_dto;
		struct participant_stats_dto;
		struct participant_timeline_dto;
		struct participant_dto;
		struct player_dto;
		struct participant_identity_dto;
		struct match_dto;
		struct match_position_dto;
		struct match_event_dto;
		struct match_frame_dto;
		struct match_participant_frame_dto;
		struct match_reference_dto;
		struct match_timeline_dto;
		struct matchlist_dto;
	}

	namespace spectator_v4
	{
		struct banned_champion;
		struct observer;
		struct perks;
		struct game_customization_object;
		struct current_game_participant;
		struct current_game_info;
		struct participant;
		struct featured_game_info;
		struct featured_games;
	}

	namespace summoner_v4
	{
		struct summoner_dto;
	}

	namespace tft_league_v1
	{
		struct mini_series_dto;
		struct league_entry_dto;
		struct league_item_dto;
		struct league_list_dto;
	}

	namespace tft_match_v1
	{
		struct companion_dto;
		struct unit_dto;
		struct trait_dto;
		struct participant_dto;
		struct info_dto;
		struct metadata_dto;
		struct match_dto;
	}

	namespace tft_summoner_v1
	{
		struct summoner_dto;
	}

	namespace third_party_code_v4
	{
	}

	namespace tournament_stub_v4
	{
		struct lobby_event_dto;
		struct lobby_event_dtowrapper;
		struct provider_registration_parameters;
		struct tournament_code_parameters;
		struct tournament_registration_parameters;
	}

	namespace tournament_v4
	{
		struct lobby_event_dto;
		struct lobby_event_dtowrapper;
		struct provider_registration_parameters;
		struct tournament_code_dto;
		struct tournament_code_parameters;
		struct tournament_code_update_parameters;
		struct tournament_registration_parameters;
	}

	namespace champion_mastery_v4
	{
		struct champion_mastery_dto
		{
			cho::champion_key champion_id;
			std::string summoner_id;
			bool chest_granted;
			int64_t last_play_time;
			int32_t tokens_earned;
			int32_t champion_level;
			int32_t champion_points;
			int64_t champion_points_since_last_level;
			int64_t champion_points_until_next_level;
		};

		/* 
			Description: Get a player&#39;s total champion mastery score, which is the sum of individual champion mastery levels. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMasteryScore
			Path: /lol/champion-mastery/v4/scores/by-summoner/{encryptedSummonerId}
		*/
		void get_champion_mastery_score_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, int32_t result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_champion_mastery_score_response
		{
			size_t response_code;
			int32_t result;
		};

		/* 
			Description: Get a player&#39;s total champion mastery score, which is the sum of individual champion mastery levels.
			Docs: https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMasteryScore
			Path: /lol/champion-mastery/v4/scores/by-summoner/{encryptedSummonerId}
		*/
		get_champion_mastery_score_response get_champion_mastery_score
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get all champion mastery entries sorted by number of champion points descending, This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getAllChampionMasteries
			Path: /lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}
		*/
		void get_all_champion_masteries_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, std::vector<champion_mastery_v4::champion_mastery_dto> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_all_champion_masteries_response
		{
			size_t response_code;
			std::vector<champion_mastery_v4::champion_mastery_dto> result;
		};

		/* 
			Description: Get all champion mastery entries sorted by number of champion points descending,
			Docs: https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getAllChampionMasteries
			Path: /lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}
		*/
		get_all_champion_masteries_response get_all_champion_masteries
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get a champion mastery by player ID and champion ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMastery
			Path: /lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}/by-champion/{championId}
		*/
		void get_champion_mastery_async
		(
			cho::platform_id a_platform,
			cho::champion_key a_champion_id,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, champion_mastery_v4::champion_mastery_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_champion_mastery_response
		{
			size_t response_code;
			champion_mastery_v4::champion_mastery_dto result;
		};

		/* 
			Description: Get a champion mastery by player ID and champion ID.
			Docs: https://developer.riotgames.com/api-methods/#champion-mastery-v4/GET_getChampionMastery
			Path: /lol/champion-mastery/v4/champion-masteries/by-summoner/{encryptedSummonerId}/by-champion/{championId}
		*/
		get_champion_mastery_response get_champion_mastery
		(
			cho::platform_id a_platform,
			cho::champion_key a_champion_id,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace champion_v3
	{
		struct champion_info
		{
			std::vector<cho::champion_key> free_champion_ids;
			int32_t max_new_player_level;
			std::vector<cho::champion_key> free_champion_ids_for_new_players;
		};

		/* 
			Description: Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST) This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#champion-v3/GET_getChampionInfo
			Path: /lol/platform/v3/champion-rotations
		*/
		void get_champion_info_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, champion_v3::champion_info result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_champion_info_response
		{
			size_t response_code;
			champion_v3::champion_info result;
		};

		/* 
			Description: Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)
			Docs: https://developer.riotgames.com/api-methods/#champion-v3/GET_getChampionInfo
			Path: /lol/platform/v3/champion-rotations
		*/
		get_champion_info_response get_champion_info
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace clash_v1
	{
		struct player_dto
		{
			std::string role;
			std::string team_id;
			std::string position;
			std::string summoner_id;
		};

		struct team_dto
		{
			std::string id;
			std::string name;
			int32_t tier;
			int32_t icon_id;
			std::string captain;
			std::vector<clash_v1::player_dto> players;
			std::string abbreviation;
			int32_t tournament_id;
		};

		struct tournament_phase_dto
		{
			int32_t id;
			bool cancelled;
			int64_t start_time;
			int64_t registration_time;
		};

		struct tournament_dto
		{
			int32_t id;
			std::string name_key;
			int32_t theme_id;
			std::vector<clash_v1::tournament_phase_dto> schedule;
			std::string name_key_secondary;
		};

		/* 
			Description: Get all active or upcoming tournaments. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getTournaments
			Path: /lol/clash/v1/tournaments
		*/
		void get_tournaments_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, std::vector<clash_v1::tournament_dto> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_tournaments_response
		{
			size_t response_code;
			std::vector<clash_v1::tournament_dto> result;
		};

		/* 
			Description: Get all active or upcoming tournaments.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getTournaments
			Path: /lol/clash/v1/tournaments
		*/
		get_tournaments_response get_tournaments
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get team by ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getTeamById
			Path: /lol/clash/v1/teams/{teamId}
		*/
		void get_team_by_id_async
		(
			cho::platform_id a_platform,
			const char* a_team_id,
			std::function<void(size_t response_code, clash_v1::team_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_team_by_id_response
		{
			size_t response_code;
			clash_v1::team_dto result;
		};

		/* 
			Description: Get team by ID.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getTeamById
			Path: /lol/clash/v1/teams/{teamId}
		*/
		get_team_by_id_response get_team_by_id
		(
			cho::platform_id a_platform,
			const char* a_team_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get tournament by ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getTournamentById
			Path: /lol/clash/v1/tournaments/{tournamentId}
		*/
		void get_tournament_by_id_async
		(
			cho::platform_id a_platform,
			int32_t a_tournament_id,
			std::function<void(size_t response_code, clash_v1::tournament_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_tournament_by_id_response
		{
			size_t response_code;
			clash_v1::tournament_dto result;
		};

		/* 
			Description: Get tournament by ID.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getTournamentById
			Path: /lol/clash/v1/tournaments/{tournamentId}
		*/
		get_tournament_by_id_response get_tournament_by_id
		(
			cho::platform_id a_platform,
			int32_t a_tournament_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get tournament by team ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getTournamentByTeam
			Path: /lol/clash/v1/tournaments/by-team/{teamId}
		*/
		void get_tournament_by_team_async
		(
			cho::platform_id a_platform,
			const char* a_team_id,
			std::function<void(size_t response_code, clash_v1::tournament_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_tournament_by_team_response
		{
			size_t response_code;
			clash_v1::tournament_dto result;
		};

		/* 
			Description: Get tournament by team ID.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getTournamentByTeam
			Path: /lol/clash/v1/tournaments/by-team/{teamId}
		*/
		get_tournament_by_team_response get_tournament_by_team
		(
			cho::platform_id a_platform,
			const char* a_team_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get players by summoner ID.\n## Implementation Notes\nThis endpoint returns a list of active Clash players for a given summoner ID. If a summoner registers for multiple tournaments at the same time (e.g., Saturday and Sunday) then both registrations would appear in this list. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getPlayersBySummoner
			Path: /lol/clash/v1/players/by-summoner/{summonerId}
		*/
		void get_players_by_summoner_async
		(
			cho::platform_id a_platform,
			const char* a_summoner_id,
			std::function<void(size_t response_code, std::vector<clash_v1::player_dto> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_players_by_summoner_response
		{
			size_t response_code;
			std::vector<clash_v1::player_dto> result;
		};

		/* 
			Description: Get players by summoner ID.\n## Implementation Notes\nThis endpoint returns a list of active Clash players for a given summoner ID. If a summoner registers for multiple tournaments at the same time (e.g., Saturday and Sunday) then both registrations would appear in this list.
			Docs: https://developer.riotgames.com/api-methods/#clash-v1/GET_getPlayersBySummoner
			Path: /lol/clash/v1/players/by-summoner/{summonerId}
		*/
		get_players_by_summoner_response get_players_by_summoner
		(
			cho::platform_id a_platform,
			const char* a_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace league_exp_v4
	{
		struct mini_series_dto
		{
			int32_t wins;
			int32_t losses;
			int32_t target;
			std::string progress;
		};

		struct league_entry_dto
		{
			std::string rank;
			std::string tier;
			int32_t wins;
			int32_t losses;
			bool veteran;
			bool inactive;
			std::string league_id;
			bool hot_streak;
			std::string queue_type;
			bool fresh_blood;
			league_exp_v4::mini_series_dto mini_series;
			std::string summoner_id;
			int32_t league_points;
			std::string summoner_name;
		};

		/*
			Optional arguments for get_league_entries
		*/
		struct get_league_entries_optional_args
		{
			cho::optional<int32_t> page;
		};
		/* 
			Description: Get all the league entries. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#league-exp-v4/GET_getLeagueEntries
			Path: /lol/league-exp/v4/entries/{queue}/{tier}/{division}
		*/
		void get_league_entries_async
		(
			cho::platform_id a_platform,
			const char* a_queue,
			const char* a_tier,
			const char* a_division,
			get_league_entries_optional_args a_optional = get_league_entries_optional_args(), 
			std::function<void(size_t response_code, std::vector<league_exp_v4::league_entry_dto> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_league_entries_response
		{
			size_t response_code;
			std::vector<league_exp_v4::league_entry_dto> result;
		};

		/* 
			Description: Get all the league entries.
			Docs: https://developer.riotgames.com/api-methods/#league-exp-v4/GET_getLeagueEntries
			Path: /lol/league-exp/v4/entries/{queue}/{tier}/{division}
		*/
		get_league_entries_response get_league_entries
		(
			cho::platform_id a_platform,
			const char* a_queue,
			const char* a_tier,
			const char* a_division,
			get_league_entries_optional_args a_optional = get_league_entries_optional_args(), 
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace league_v4
	{
		struct mini_series_dto
		{
			int32_t wins;
			int32_t losses;
			int32_t target;
			std::string progress;
		};

		struct league_entry_dto
		{
			std::string rank;
			std::string tier;
			int32_t wins;
			int32_t losses;
			bool veteran;
			bool inactive;
			std::string league_id;
			bool hot_streak;
			std::string queue_type;
			bool fresh_blood;
			league_v4::mini_series_dto mini_series;
			std::string summoner_id;
			int32_t league_points;
			std::string summoner_name;
		};

		struct league_item_dto
		{
			std::string rank;
			int32_t wins;
			int32_t losses;
			bool veteran;
			bool inactive;
			bool hot_streak;
			bool fresh_blood;
			league_v4::mini_series_dto mini_series;
			std::string summoner_id;
			int32_t league_points;
			std::string summoner_name;
		};

		struct league_list_dto
		{
			std::string name;
			std::string tier;
			std::string queue;
			std::vector<league_v4::league_item_dto> entries;
			std::string league_id;
		};

		/* 
			Description: Get league with given ID, including inactive entries. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueById
			Path: /lol/league/v4/leagues/{leagueId}
		*/
		void get_league_by_id_async
		(
			cho::platform_id a_platform,
			const char* a_league_id,
			std::function<void(size_t response_code, league_v4::league_list_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_league_by_id_response
		{
			size_t response_code;
			league_v4::league_list_dto result;
		};

		/* 
			Description: Get league with given ID, including inactive entries.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueById
			Path: /lol/league/v4/leagues/{leagueId}
		*/
		get_league_by_id_response get_league_by_id
		(
			cho::platform_id a_platform,
			const char* a_league_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get the master league for given queue. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getMasterLeague
			Path: /lol/league/v4/masterleagues/by-queue/{queue}
		*/
		void get_master_league_async
		(
			cho::platform_id a_platform,
			const char* a_queue,
			std::function<void(size_t response_code, league_v4::league_list_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_master_league_response
		{
			size_t response_code;
			league_v4::league_list_dto result;
		};

		/* 
			Description: Get the master league for given queue.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getMasterLeague
			Path: /lol/league/v4/masterleagues/by-queue/{queue}
		*/
		get_master_league_response get_master_league
		(
			cho::platform_id a_platform,
			const char* a_queue,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/*
			Optional arguments for get_league_entries
		*/
		struct get_league_entries_optional_args
		{
			cho::optional<int32_t> page;
		};
		/* 
			Description: Get all the league entries. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntries
			Path: /lol/league/v4/entries/{queue}/{tier}/{division}
		*/
		void get_league_entries_async
		(
			cho::platform_id a_platform,
			const char* a_division,
			const char* a_tier,
			const char* a_queue,
			get_league_entries_optional_args a_optional = get_league_entries_optional_args(), 
			std::function<void(size_t response_code, std::vector<league_v4::league_entry_dto> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_league_entries_response
		{
			size_t response_code;
			std::vector<league_v4::league_entry_dto> result;
		};

		/* 
			Description: Get all the league entries.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntries
			Path: /lol/league/v4/entries/{queue}/{tier}/{division}
		*/
		get_league_entries_response get_league_entries
		(
			cho::platform_id a_platform,
			const char* a_division,
			const char* a_tier,
			const char* a_queue,
			get_league_entries_optional_args a_optional = get_league_entries_optional_args(), 
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get the challenger league for given queue. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getChallengerLeague
			Path: /lol/league/v4/challengerleagues/by-queue/{queue}
		*/
		void get_challenger_league_async
		(
			cho::platform_id a_platform,
			const char* a_queue,
			std::function<void(size_t response_code, league_v4::league_list_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_challenger_league_response
		{
			size_t response_code;
			league_v4::league_list_dto result;
		};

		/* 
			Description: Get the challenger league for given queue.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getChallengerLeague
			Path: /lol/league/v4/challengerleagues/by-queue/{queue}
		*/
		get_challenger_league_response get_challenger_league
		(
			cho::platform_id a_platform,
			const char* a_queue,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get the grandmaster league of a specific queue. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getGrandmasterLeague
			Path: /lol/league/v4/grandmasterleagues/by-queue/{queue}
		*/
		void get_grandmaster_league_async
		(
			cho::platform_id a_platform,
			const char* a_queue,
			std::function<void(size_t response_code, league_v4::league_list_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_grandmaster_league_response
		{
			size_t response_code;
			league_v4::league_list_dto result;
		};

		/* 
			Description: Get the grandmaster league of a specific queue.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getGrandmasterLeague
			Path: /lol/league/v4/grandmasterleagues/by-queue/{queue}
		*/
		get_grandmaster_league_response get_grandmaster_league
		(
			cho::platform_id a_platform,
			const char* a_queue,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get league entries in all queues for a given summoner ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntriesForSummoner
			Path: /lol/league/v4/entries/by-summoner/{encryptedSummonerId}
		*/
		void get_league_entries_for_summoner_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, std::vector<league_v4::league_entry_dto> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_league_entries_for_summoner_response
		{
			size_t response_code;
			std::vector<league_v4::league_entry_dto> result;
		};

		/* 
			Description: Get league entries in all queues for a given summoner ID.
			Docs: https://developer.riotgames.com/api-methods/#league-v4/GET_getLeagueEntriesForSummoner
			Path: /lol/league/v4/entries/by-summoner/{encryptedSummonerId}
		*/
		get_league_entries_for_summoner_response get_league_entries_for_summoner
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace lol_status_v3
	{
		struct translation
		{
			std::string locale;
			std::string content;
			std::string heading;
		};

		struct message
		{
			std::string id;
			std::string author;
			std::string content;
			std::string severity;
			std::string created_at;
			std::string updated_at;
			std::vector<lol_status_v3::translation> translations;
		};

		struct incident
		{
			int64_t id;
			bool active;
			std::vector<lol_status_v3::message> updates;
			std::string created_at;
		};

		struct service
		{
			std::string name;
			std::string slug;
			std::string status;
			std::vector<lol_status_v3::incident> incidents;
		};

		struct shard_status
		{
			std::string name;
			std::string slug;
			std::vector<std::string> locales;
			std::string hostname;
			std::vector<lol_status_v3::service> services;
			std::string region_tag;
		};

		/* 
			Description: Get League of Legends status for the given shard.\n## Rate Limit Notes\nRequests to this API are not counted against the application Rate Limits. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#lol-status-v3/GET_getShardData
			Path: /lol/status/v3/shard-data
		*/
		void get_shard_data_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, lol_status_v3::shard_status result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_shard_data_response
		{
			size_t response_code;
			lol_status_v3::shard_status result;
		};

		/* 
			Description: Get League of Legends status for the given shard.\n## Rate Limit Notes\nRequests to this API are not counted against the application Rate Limits.
			Docs: https://developer.riotgames.com/api-methods/#lol-status-v3/GET_getShardData
			Path: /lol/status/v3/shard-data
		*/
		get_shard_data_response get_shard_data
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace lor_ranked_v1
	{
		struct player_dto
		{
			std::string name;
			int32_t rank;
		};

		struct leaderboard_dto
		{
			std::vector<lor_ranked_v1::player_dto> players;
		};

		/* 
			Description: Get the players in Master tier. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#lor-ranked-v1/GET_getLeaderboards
			Path: /lor/ranked/v1/leaderboards
		*/
		void get_leaderboards_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, lor_ranked_v1::leaderboard_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_leaderboards_response
		{
			size_t response_code;
			lor_ranked_v1::leaderboard_dto result;
		};

		/* 
			Description: Get the players in Master tier.
			Docs: https://developer.riotgames.com/api-methods/#lor-ranked-v1/GET_getLeaderboards
			Path: /lor/ranked/v1/leaderboards
		*/
		get_leaderboards_response get_leaderboards
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace match_v4
	{
		struct mastery_dto
		{
			int32_t rank;
			int32_t mastery_id;
		};

		struct team_bans_dto
		{
			int32_t pick_turn;
			cho::champion_key champion_id;
		};

		struct team_stats_dto
		{
			std::string win;
			std::vector<match_v4::team_bans_dto> bans;
			int32_t team_id;
			int32_t baron_kills;
			bool first_baron;
			bool first_blood;
			bool first_tower;
			int32_t tower_kills;
			int32_t dragon_kills;
			bool first_dragon;
			int32_t vilemaw_kills;
			bool first_inhibitor;
			int32_t inhibitor_kills;
			bool first_rift_herald;
			int32_t rift_herald_kills;
			int32_t dominion_victory_score;
		};

		struct rune_dto
		{
			int32_t rank;
			int32_t rune_id;
		};

		struct participant_stats_dto
		{
			bool win;
			int32_t item0;
			int32_t item1;
			int32_t item2;
			int32_t item3;
			int32_t item4;
			int32_t item5;
			int32_t item6;
			int32_t kills;
			int32_t perk0;
			int32_t perk1;
			int32_t perk2;
			int32_t perk3;
			int32_t perk4;
			int32_t perk5;
			int32_t deaths;
			int32_t assists;
			int32_t gold_spent;
			int32_t perk0var1;
			int32_t perk0var2;
			int32_t perk0var3;
			int32_t perk1var1;
			int32_t perk1var2;
			int32_t perk1var3;
			int32_t perk2var1;
			int32_t perk2var2;
			int32_t perk2var3;
			int32_t perk3var1;
			int32_t perk3var2;
			int32_t perk3var3;
			int32_t perk4var1;
			int32_t perk4var2;
			int32_t perk4var3;
			int32_t perk5var1;
			int32_t perk5var2;
			int32_t perk5var3;
			int64_t total_heal;
			int32_t champ_level;
			int32_t gold_earned;
			int32_t penta_kills;
			int32_t double_kills;
			int32_t node_capture;
			int32_t quadra_kills;
			int32_t triple_kills;
			int32_t turret_kills;
			int32_t unreal_kills;
			int64_t vision_score;
			int32_t wards_killed;
			int32_t wards_placed;
			int32_t perk_sub_style;
			int32_t player_score0;
			int32_t player_score1;
			int32_t player_score2;
			int32_t player_score3;
			int32_t player_score4;
			int32_t player_score5;
			int32_t player_score6;
			int32_t player_score7;
			int32_t player_score8;
			int32_t player_score9;
			int32_t killing_sprees;
			int32_t participant_id;
			int32_t team_objective;
			int32_t altars_captured;
			bool first_blood_kill;
			bool first_tower_kill;
			int32_t inhibitor_kills;
			int32_t node_neutralize;
			int32_t total_score_rank;
			int64_t time_ccing_others;
			int64_t true_damage_dealt;
			int64_t true_damage_taken;
			bool first_blood_assist;
			bool first_tower_assist;
			int32_t largest_multi_kill;
			int64_t magic_damage_dealt;
			int32_t perk_primary_style;
			int64_t total_damage_dealt;
			int64_t total_damage_taken;
			int32_t total_player_score;
			int32_t total_units_healed;
			int32_t altars_neutralized;
			int32_t combat_player_score;
			int32_t node_capture_assist;
			bool first_inhibitor_kill;
			int64_t magical_damage_taken;
			int32_t total_minions_killed;
			int64_t damage_self_mitigated;
			int32_t largest_killing_spree;
			int64_t physical_damage_dealt;
			int64_t physical_damage_taken;
			int64_t damage_dealt_to_turrets;
			bool first_inhibitor_assist;
			int32_t neutral_minions_killed;
			int32_t node_neutralize_assist;
			int32_t objective_player_score;
			int32_t largest_critical_strike;
			int32_t longest_time_spent_living;
			int32_t sight_wards_bought_in_game;
			int64_t damage_dealt_to_objectives;
			int32_t vision_wards_bought_in_game;
			int32_t total_time_crowd_control_dealt;
			int64_t true_damage_dealt_to_champions;
			int64_t magic_damage_dealt_to_champions;
			int64_t total_damage_dealt_to_champions;
			int32_t neutral_minions_killed_team_jungle;
			int64_t physical_damage_dealt_to_champions;
			int32_t neutral_minions_killed_enemy_jungle;
		};

		struct participant_timeline_dto
		{
			std::string lane;
			std::string role;
			int32_t participant_id;
			std::map<std::string, double> xp_per_min_deltas;
			std::map<std::string, double> gold_per_min_deltas;
			std::map<std::string, double> creeps_per_min_deltas;
			std::map<std::string, double> cs_diff_per_min_deltas;
			std::map<std::string, double> xp_diff_per_min_deltas;
			std::map<std::string, double> damage_taken_per_min_deltas;
			std::map<std::string, double> damage_taken_diff_per_min_deltas;
		};

		struct participant_dto
		{
			std::vector<match_v4::rune_dto> runes;
			match_v4::participant_stats_dto stats;
			int32_t team_id;
			int32_t spell1id;
			int32_t spell2id;
			match_v4::participant_timeline_dto timeline;
			std::vector<match_v4::mastery_dto> masteries;
			cho::champion_key champion_id;
			int32_t participant_id;
			std::string highest_achieved_season_tier;
		};

		struct player_dto
		{
			std::string account_id;
			std::string platform_id;
			std::string summoner_id;
			int32_t profile_icon;
			std::string summoner_name;
			std::string match_history_uri;
			std::string current_account_id;
			std::string current_platform_id;
		};

		struct participant_identity_dto
		{
			match_v4::player_dto player;
			int32_t participant_id;
		};

		struct match_dto
		{
			int32_t map_id;
			std::vector<match_v4::team_stats_dto> teams;
			int64_t game_id;
			int32_t queue_id;
			std::string game_mode;
			std::string game_type;
			int32_t season_id;
			std::string platform_id;
			std::string game_version;
			int64_t game_creation;
			int64_t game_duration;
			std::vector<match_v4::participant_dto> participants;
			std::vector<match_v4::participant_identity_dto> participant_identities;
		};

		struct match_position_dto
		{
			int32_t x;
			int32_t y;
		};

		struct match_event_dto
		{
			std::string type;
			int32_t item_id;
			int32_t team_id;
			int32_t after_id;
			int32_t before_id;
			int32_t killer_id;
			std::string lane_type;
			match_v4::match_position_dto position;
			int32_t victim_id;
			std::string ward_type;
			int32_t creator_id;
			std::string event_type;
			int32_t skill_slot;
			int64_t timestamp;
			std::string tower_type;
			std::string level_up_type;
			std::string monster_type;
			std::string ascended_type;
			std::string building_type;
			int32_t participant_id;
			std::string point_captured;
			std::string monster_sub_type;
			std::vector<int32_t> assisting_participant_ids;
		};

		struct match_frame_dto
		{
			std::vector<match_v4::match_event_dto> events;
			int64_t timestamp;
			std::map<std::string, match_v4::match_participant_frame_dto> participant_frames;
		};

		struct match_participant_frame_dto
		{
			int32_t xp;
			int32_t level;
			match_v4::match_position_dto position;
			int32_t team_score;
			int32_t total_gold;
			int32_t current_gold;
			int32_t dominion_score;
			int32_t minions_killed;
			int32_t participant_id;
			int32_t jungle_minions_killed;
		};

		struct match_reference_dto
		{
			std::string lane;
			std::string role;
			int32_t queue;
			int64_t game_id;
			int32_t season;
			cho::champion_key champion;
			int64_t timestamp;
			std::string platform_id;
		};

		struct match_timeline_dto
		{
			std::vector<match_v4::match_frame_dto> frames;
			int64_t frame_interval;
		};

		struct matchlist_dto
		{
			std::vector<match_v4::match_reference_dto> matches;
			int32_t end_index;
			int32_t start_index;
			int32_t total_games;
		};

		/* 
			Description: Get match by match ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch
			Path: /lol/match/v4/matches/{matchId}
		*/
		void get_match_async
		(
			cho::platform_id a_platform,
			int64_t a_match_id,
			std::function<void(size_t response_code, match_v4::match_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_match_response
		{
			size_t response_code;
			match_v4::match_dto result;
		};

		/* 
			Description: Get match by match ID.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatch
			Path: /lol/match/v4/matches/{matchId}
		*/
		get_match_response get_match
		(
			cho::platform_id a_platform,
			int64_t a_match_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get match timeline by match ID.\n## Implementation Notes\nNot all matches have timeline data. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline
			Path: /lol/match/v4/timelines/by-match/{matchId}
		*/
		void get_match_timeline_async
		(
			cho::platform_id a_platform,
			int64_t a_match_id,
			std::function<void(size_t response_code, match_v4::match_timeline_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_match_timeline_response
		{
			size_t response_code;
			match_v4::match_timeline_dto result;
		};

		/* 
			Description: Get match timeline by match ID.\n## Implementation Notes\nNot all matches have timeline data.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchTimeline
			Path: /lol/match/v4/timelines/by-match/{matchId}
		*/
		get_match_timeline_response get_match_timeline
		(
			cho::platform_id a_platform,
			int64_t a_match_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/*
			Optional arguments for get_matchlist
		*/
		struct get_matchlist_optional_args
		{
			cho::optional<std::vector<cho::champion_key>> champion;
			cho::optional<std::vector<int32_t>> queue;
			cho::optional<std::vector<int32_t>> season;
			cho::optional<int64_t> end_time;
			cho::optional<int64_t> begin_time;
			cho::optional<int32_t> end_index;
			cho::optional<int32_t> begin_index;
		};
		/* 
			Description: Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.\n## Implementation Notes\nA number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.\n\nIf beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.\n\nIf beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist
			Path: /lol/match/v4/matchlists/by-account/{encryptedAccountId}
		*/
		void get_matchlist_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			get_matchlist_optional_args a_optional = get_matchlist_optional_args(), 
			std::function<void(size_t response_code, match_v4::matchlist_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_matchlist_response
		{
			size_t response_code;
			match_v4::matchlist_dto result;
		};

		/* 
			Description: Get matchlist for games played on given account ID and platform ID and filtered using given filter parameters, if any.\n## Implementation Notes\nA number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested account, otherwise, no matches may be returned.\n\nIf beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex, then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex. The maximum range allowed is 100, otherwise a 400 error code is returned.\n\nIf beginTime is specified, but not endTime, then endTime defaults to the the current unix timestamp in milliseconds (the maximum time range limitation is not observed in this specific case). If endTime is specified, but not beginTime, then beginTime defaults to the start of the account&#39;s match history returning a 400 due to the maximum time range limitation. If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week, otherwise a 400 error code is returned.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchlist
			Path: /lol/match/v4/matchlists/by-account/{encryptedAccountId}
		*/
		get_matchlist_response get_matchlist
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			get_matchlist_optional_args a_optional = get_matchlist_optional_args(), 
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get match IDs by tournament code. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode
			Path: /lol/match/v4/matches/by-tournament-code/{tournamentCode}/ids
		*/
		void get_match_ids_by_tournament_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code, std::vector<int64_t> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_match_ids_by_tournament_code_response
		{
			size_t response_code;
			std::vector<int64_t> result;
		};

		/* 
			Description: Get match IDs by tournament code.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchIdsByTournamentCode
			Path: /lol/match/v4/matches/by-tournament-code/{tournamentCode}/ids
		*/
		get_match_ids_by_tournament_code_response get_match_ids_by_tournament_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get match by match ID and tournament code. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode
			Path: /lol/match/v4/matches/{matchId}/by-tournament-code/{tournamentCode}
		*/
		void get_match_by_tournament_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			int64_t a_match_id,
			std::function<void(size_t response_code, match_v4::match_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_match_by_tournament_code_response
		{
			size_t response_code;
			match_v4::match_dto result;
		};

		/* 
			Description: Get match by match ID and tournament code.
			Docs: https://developer.riotgames.com/api-methods/#match-v4/GET_getMatchByTournamentCode
			Path: /lol/match/v4/matches/{matchId}/by-tournament-code/{tournamentCode}
		*/
		get_match_by_tournament_code_response get_match_by_tournament_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			int64_t a_match_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace spectator_v4
	{
		struct banned_champion
		{
			int64_t team_id;
			int32_t pick_turn;
			cho::champion_key champion_id;
		};

		struct observer
		{
			std::string encryption_key;
		};

		struct perks
		{
			std::vector<int64_t> perk_ids;
			int64_t perk_style;
			int64_t perk_sub_style;
		};

		struct game_customization_object
		{
			std::string content;
			std::string category;
		};

		struct current_game_participant
		{
			bool bot;
			spectator_v4::perks perks;
			int64_t team_id;
			int64_t spell1id;
			int64_t spell2id;
			cho::champion_key champion_id;
			std::string summoner_id;
			std::string summoner_name;
			int64_t profile_icon_id;
			std::vector<spectator_v4::game_customization_object> game_customization_objects;
		};

		struct current_game_info
		{
			int64_t map_id;
			int64_t game_id;
			std::string game_mode;
			std::string game_type;
			spectator_v4::observer observers;
			int64_t game_length;
			std::string platform_id;
			std::vector<spectator_v4::current_game_participant> participants;
			int64_t game_start_time;
			std::vector<spectator_v4::banned_champion> banned_champions;
			int64_t game_queue_config_id;
		};

		struct participant
		{
			bool bot;
			int64_t team_id;
			int64_t spell1id;
			int64_t spell2id;
			cho::champion_key champion_id;
			std::string summoner_name;
			int64_t profile_icon_id;
		};

		struct featured_game_info
		{
			int64_t map_id;
			int64_t game_id;
			std::string game_mode;
			std::string game_type;
			spectator_v4::observer observers;
			int64_t game_length;
			std::string platform_id;
			std::vector<spectator_v4::participant> participants;
			int64_t game_start_time;
			std::vector<spectator_v4::banned_champion> banned_champions;
			int64_t game_queue_config_id;
		};

		struct featured_games
		{
			std::vector<spectator_v4::featured_game_info> game_list;
			int64_t client_refresh_interval;
		};

		/* 
			Description: Get list of featured games. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#spectator-v4/GET_getFeaturedGames
			Path: /lol/spectator/v4/featured-games
		*/
		void get_featured_games_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, spectator_v4::featured_games result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_featured_games_response
		{
			size_t response_code;
			spectator_v4::featured_games result;
		};

		/* 
			Description: Get list of featured games.
			Docs: https://developer.riotgames.com/api-methods/#spectator-v4/GET_getFeaturedGames
			Path: /lol/spectator/v4/featured-games
		*/
		get_featured_games_response get_featured_games
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get current game information for the given summoner ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#spectator-v4/GET_getCurrentGameInfoBySummoner
			Path: /lol/spectator/v4/active-games/by-summoner/{encryptedSummonerId}
		*/
		void get_current_game_info_by_summoner_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, spectator_v4::current_game_info result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_current_game_info_by_summoner_response
		{
			size_t response_code;
			spectator_v4::current_game_info result;
		};

		/* 
			Description: Get current game information for the given summoner ID.
			Docs: https://developer.riotgames.com/api-methods/#spectator-v4/GET_getCurrentGameInfoBySummoner
			Path: /lol/spectator/v4/active-games/by-summoner/{encryptedSummonerId}
		*/
		get_current_game_info_by_summoner_response get_current_game_info_by_summoner
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace summoner_v4
	{
		struct summoner_dto
		{
			std::string id;
			std::string name;
			std::string puuid;
			std::string account_id;
			int64_t revision_date;
			int32_t profile_icon_id;
			int64_t summoner_level;
		};

		/* 
			Description: Get a summoner by summoner ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerId
			Path: /lol/summoner/v4/summoners/{encryptedSummonerId}
		*/
		void get_by_summoner_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, summoner_v4::summoner_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_by_summoner_id_response
		{
			size_t response_code;
			summoner_v4::summoner_dto result;
		};

		/* 
			Description: Get a summoner by summoner ID.
			Docs: https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerId
			Path: /lol/summoner/v4/summoners/{encryptedSummonerId}
		*/
		get_by_summoner_id_response get_by_summoner_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get a summoner by summoner name. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerName
			Path: /lol/summoner/v4/summoners/by-name/{summonerName}
		*/
		void get_by_summoner_name_async
		(
			cho::platform_id a_platform,
			const char* a_summoner_name,
			std::function<void(size_t response_code, summoner_v4::summoner_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_by_summoner_name_response
		{
			size_t response_code;
			summoner_v4::summoner_dto result;
		};

		/* 
			Description: Get a summoner by summoner name.
			Docs: https://developer.riotgames.com/api-methods/#summoner-v4/GET_getBySummonerName
			Path: /lol/summoner/v4/summoners/by-name/{summonerName}
		*/
		get_by_summoner_name_response get_by_summoner_name
		(
			cho::platform_id a_platform,
			const char* a_summoner_name,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get a summoner by PUUID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByPUUID
			Path: /lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}
		*/
		void get_by_puuid_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_puuid,
			std::function<void(size_t response_code, summoner_v4::summoner_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_by_puuid_response
		{
			size_t response_code;
			summoner_v4::summoner_dto result;
		};

		/* 
			Description: Get a summoner by PUUID.
			Docs: https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByPUUID
			Path: /lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}
		*/
		get_by_puuid_response get_by_puuid
		(
			cho::platform_id a_platform,
			const char* a_encrypted_puuid,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get a summoner by account ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByAccountId
			Path: /lol/summoner/v4/summoners/by-account/{encryptedAccountId}
		*/
		void get_by_account_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			std::function<void(size_t response_code, summoner_v4::summoner_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_by_account_id_response
		{
			size_t response_code;
			summoner_v4::summoner_dto result;
		};

		/* 
			Description: Get a summoner by account ID.
			Docs: https://developer.riotgames.com/api-methods/#summoner-v4/GET_getByAccountId
			Path: /lol/summoner/v4/summoners/by-account/{encryptedAccountId}
		*/
		get_by_account_id_response get_by_account_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace tft_league_v1
	{
		struct mini_series_dto
		{
			int32_t wins;
			int32_t losses;
			int32_t target;
			std::string progress;
		};

		struct league_entry_dto
		{
			std::string rank;
			std::string tier;
			int32_t wins;
			int32_t losses;
			bool veteran;
			bool inactive;
			std::string league_id;
			bool hot_streak;
			std::string queue_type;
			bool fresh_blood;
			tft_league_v1::mini_series_dto mini_series;
			std::string summoner_id;
			int32_t league_points;
			std::string summoner_name;
		};

		struct league_item_dto
		{
			std::string rank;
			int32_t wins;
			int32_t losses;
			bool veteran;
			bool inactive;
			bool hot_streak;
			bool fresh_blood;
			tft_league_v1::mini_series_dto mini_series;
			std::string summoner_id;
			int32_t league_points;
			std::string summoner_name;
		};

		struct league_list_dto
		{
			std::string name;
			std::string tier;
			std::string queue;
			std::vector<tft_league_v1::league_item_dto> entries;
			std::string league_id;
		};

		/* 
			Description: Get the master league. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getMasterLeague
			Path: /tft/league/v1/master
		*/
		void get_master_league_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, tft_league_v1::league_list_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_master_league_response
		{
			size_t response_code;
			tft_league_v1::league_list_dto result;
		};

		/* 
			Description: Get the master league.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getMasterLeague
			Path: /tft/league/v1/master
		*/
		get_master_league_response get_master_league
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get the challenger league. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getChallengerLeague
			Path: /tft/league/v1/challenger
		*/
		void get_challenger_league_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, tft_league_v1::league_list_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_challenger_league_response
		{
			size_t response_code;
			tft_league_v1::league_list_dto result;
		};

		/* 
			Description: Get the challenger league.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getChallengerLeague
			Path: /tft/league/v1/challenger
		*/
		get_challenger_league_response get_challenger_league
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get the grandmaster league. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getGrandmasterLeague
			Path: /tft/league/v1/grandmaster
		*/
		void get_grandmaster_league_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, tft_league_v1::league_list_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_grandmaster_league_response
		{
			size_t response_code;
			tft_league_v1::league_list_dto result;
		};

		/* 
			Description: Get the grandmaster league.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getGrandmasterLeague
			Path: /tft/league/v1/grandmaster
		*/
		get_grandmaster_league_response get_grandmaster_league
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get league with given ID, including inactive entries. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getLeagueById
			Path: /tft/league/v1/leagues/{leagueId}
		*/
		void get_league_by_id_async
		(
			cho::platform_id a_platform,
			const char* a_league_id,
			std::function<void(size_t response_code, tft_league_v1::league_list_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_league_by_id_response
		{
			size_t response_code;
			tft_league_v1::league_list_dto result;
		};

		/* 
			Description: Get league with given ID, including inactive entries.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getLeagueById
			Path: /tft/league/v1/leagues/{leagueId}
		*/
		get_league_by_id_response get_league_by_id
		(
			cho::platform_id a_platform,
			const char* a_league_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/*
			Optional arguments for get_league_entries
		*/
		struct get_league_entries_optional_args
		{
			cho::optional<int32_t> page;
		};
		/* 
			Description: Get all the league entries. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getLeagueEntries
			Path: /tft/league/v1/entries/{tier}/{division}
		*/
		void get_league_entries_async
		(
			cho::platform_id a_platform,
			const char* a_tier,
			const char* a_division,
			get_league_entries_optional_args a_optional = get_league_entries_optional_args(), 
			std::function<void(size_t response_code, std::vector<tft_league_v1::league_entry_dto> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_league_entries_response
		{
			size_t response_code;
			std::vector<tft_league_v1::league_entry_dto> result;
		};

		/* 
			Description: Get all the league entries.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getLeagueEntries
			Path: /tft/league/v1/entries/{tier}/{division}
		*/
		get_league_entries_response get_league_entries
		(
			cho::platform_id a_platform,
			const char* a_tier,
			const char* a_division,
			get_league_entries_optional_args a_optional = get_league_entries_optional_args(), 
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get league entries for a given summoner ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getLeagueEntriesForSummoner
			Path: /tft/league/v1/entries/by-summoner/{encryptedSummonerId}
		*/
		void get_league_entries_for_summoner_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, std::vector<tft_league_v1::league_entry_dto> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_league_entries_for_summoner_response
		{
			size_t response_code;
			std::vector<tft_league_v1::league_entry_dto> result;
		};

		/* 
			Description: Get league entries for a given summoner ID.
			Docs: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getLeagueEntriesForSummoner
			Path: /tft/league/v1/entries/by-summoner/{encryptedSummonerId}
		*/
		get_league_entries_for_summoner_response get_league_entries_for_summoner
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace tft_match_v1
	{
		struct companion_dto
		{
			int32_t skin_id;
			std::string species;
			std::string content_id;
		};

		struct unit_dto
		{
			std::string name;
			int32_t tier;
			std::vector<int32_t> items;
			int32_t rarity;
			std::string character_id;
		};

		struct trait_dto
		{
			std::string name;
			int32_t num_units;
			int32_t tier_total;
			int32_t tier_current;
		};

		struct participant_dto
		{
			int32_t level;
			std::string puuid;
			std::vector<tft_match_v1::unit_dto> units;
			std::vector<tft_match_v1::trait_dto> traits;
			tft_match_v1::companion_dto companion;
			int32_t gold_left;
			int32_t placement;
			int32_t last_round;
			float time_eliminated;
			int32_t players_eliminated;
			int32_t total_damage_to_players;
		};

		struct info_dto
		{
			int32_t queue_id;
			float game_length;
			std::string game_version;
			std::vector<tft_match_v1::participant_dto> participants;
			int64_t game_datetime;
			int32_t tft_set_number;
		};

		struct metadata_dto
		{
			std::string match_id;
			std::string data_version;
			std::vector<std::string> participants;
		};

		struct match_dto
		{
			tft_match_v1::info_dto info;
			tft_match_v1::metadata_dto metadata;
		};

		/* 
			Description: Get a match by match id. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-match-v1/GET_getMatch
			Path: /tft/match/v1/matches/{matchId}
		*/
		void get_match_async
		(
			cho::platform_id a_platform,
			const char* a_match_id,
			std::function<void(size_t response_code, tft_match_v1::match_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_match_response
		{
			size_t response_code;
			tft_match_v1::match_dto result;
		};

		/* 
			Description: Get a match by match id.
			Docs: https://developer.riotgames.com/api-methods/#tft-match-v1/GET_getMatch
			Path: /tft/match/v1/matches/{matchId}
		*/
		get_match_response get_match
		(
			cho::platform_id a_platform,
			const char* a_match_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/*
			Optional arguments for get_match_ids_by_puuid
		*/
		struct get_match_ids_by_puuid_optional_args
		{
			cho::optional<int32_t> count;
		};
		/* 
			Description: Get a list of match ids by PUUID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-match-v1/GET_getMatchIdsByPUUID
			Path: /tft/match/v1/matches/by-puuid/{puuid}/ids
		*/
		void get_match_ids_by_puuid_async
		(
			cho::platform_id a_platform,
			const char* a_puuid,
			get_match_ids_by_puuid_optional_args a_optional = get_match_ids_by_puuid_optional_args(), 
			std::function<void(size_t response_code, std::vector<std::string> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_match_ids_by_puuid_response
		{
			size_t response_code;
			std::vector<std::string> result;
		};

		/* 
			Description: Get a list of match ids by PUUID.
			Docs: https://developer.riotgames.com/api-methods/#tft-match-v1/GET_getMatchIdsByPUUID
			Path: /tft/match/v1/matches/by-puuid/{puuid}/ids
		*/
		get_match_ids_by_puuid_response get_match_ids_by_puuid
		(
			cho::platform_id a_platform,
			const char* a_puuid,
			get_match_ids_by_puuid_optional_args a_optional = get_match_ids_by_puuid_optional_args(), 
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace tft_summoner_v1
	{
		struct summoner_dto
		{
			std::string id;
			std::string name;
			std::string puuid;
			std::string account_id;
			int64_t revision_date;
			int32_t profile_icon_id;
			int64_t summoner_level;
		};

		/* 
			Description: Get a summoner by summoner ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getBySummonerId
			Path: /tft/summoner/v1/summoners/{encryptedSummonerId}
		*/
		void get_by_summoner_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, tft_summoner_v1::summoner_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_by_summoner_id_response
		{
			size_t response_code;
			tft_summoner_v1::summoner_dto result;
		};

		/* 
			Description: Get a summoner by summoner ID.
			Docs: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getBySummonerId
			Path: /tft/summoner/v1/summoners/{encryptedSummonerId}
		*/
		get_by_summoner_id_response get_by_summoner_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get a summoner by summoner name. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getBySummonerName
			Path: /tft/summoner/v1/summoners/by-name/{summonerName}
		*/
		void get_by_summoner_name_async
		(
			cho::platform_id a_platform,
			const char* a_summoner_name,
			std::function<void(size_t response_code, tft_summoner_v1::summoner_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_by_summoner_name_response
		{
			size_t response_code;
			tft_summoner_v1::summoner_dto result;
		};

		/* 
			Description: Get a summoner by summoner name.
			Docs: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getBySummonerName
			Path: /tft/summoner/v1/summoners/by-name/{summonerName}
		*/
		get_by_summoner_name_response get_by_summoner_name
		(
			cho::platform_id a_platform,
			const char* a_summoner_name,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get a summoner by PUUID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getByPUUID
			Path: /tft/summoner/v1/summoners/by-puuid/{encryptedPUUID}
		*/
		void get_by_puuid_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_puuid,
			std::function<void(size_t response_code, tft_summoner_v1::summoner_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_by_puuid_response
		{
			size_t response_code;
			tft_summoner_v1::summoner_dto result;
		};

		/* 
			Description: Get a summoner by PUUID.
			Docs: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getByPUUID
			Path: /tft/summoner/v1/summoners/by-puuid/{encryptedPUUID}
		*/
		get_by_puuid_response get_by_puuid
		(
			cho::platform_id a_platform,
			const char* a_encrypted_puuid,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Get a summoner by account ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getByAccountId
			Path: /tft/summoner/v1/summoners/by-account/{encryptedAccountId}
		*/
		void get_by_account_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			std::function<void(size_t response_code, tft_summoner_v1::summoner_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_by_account_id_response
		{
			size_t response_code;
			tft_summoner_v1::summoner_dto result;
		};

		/* 
			Description: Get a summoner by account ID.
			Docs: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getByAccountId
			Path: /tft/summoner/v1/summoners/by-account/{encryptedAccountId}
		*/
		get_by_account_id_response get_by_account_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_account_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace third_party_code_v4
	{
		/* 
			Description: Get third party code for a given summoner ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#third-party-code-v4/GET_getThirdPartyCodeBySummonerId
			Path: /lol/platform/v4/third-party-code/by-summoner/{encryptedSummonerId}
		*/
		void get_third_party_code_by_summoner_id_async
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			std::function<void(size_t response_code, std::string result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_third_party_code_by_summoner_id_response
		{
			size_t response_code;
			std::string result;
		};

		/* 
			Description: Get third party code for a given summoner ID.
			Docs: https://developer.riotgames.com/api-methods/#third-party-code-v4/GET_getThirdPartyCodeBySummonerId
			Path: /lol/platform/v4/third-party-code/by-summoner/{encryptedSummonerId}
		*/
		get_third_party_code_by_summoner_id_response get_third_party_code_by_summoner_id
		(
			cho::platform_id a_platform,
			const char* a_encrypted_summoner_id,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace tournament_stub_v4
	{
		struct lobby_event_dto
		{
			std::string event_type;
			std::string timestamp;
			std::string summoner_id;
		};

		struct lobby_event_dtowrapper
		{
			std::vector<tournament_stub_v4::lobby_event_dto> event_list;
		};

		struct provider_registration_parameters
		{
			std::string url;
			std::string region;
		};

		struct tournament_code_parameters
		{
			std::string map_type;
			std::string metadata;
			std::string pick_type;
			int32_t team_size;
			std::string spectator_type;
			std::vector<std::string> allowed_summoner_ids;
		};

		struct tournament_registration_parameters
		{
			std::string name;
			int32_t provider_id;
		};

		/*
			Optional arguments for create_tournament_code
		*/
		struct create_tournament_code_optional_args
		{
			cho::optional<int32_t> count;
		};
		/* 
			Description: Create a mock tournament code for the given tournament. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-stub-v4/POST_createTournamentCode
			Path: /lol/tournament-stub/v4/codes
		*/
		void create_tournament_code_async
		(
			cho::platform_id a_platform,
			int64_t a_tournament_id,
			create_tournament_code_optional_args a_optional = create_tournament_code_optional_args(), 
			std::function<void(size_t response_code, std::vector<std::string> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct create_tournament_code_response
		{
			size_t response_code;
			std::vector<std::string> result;
		};

		/* 
			Description: Create a mock tournament code for the given tournament.
			Docs: https://developer.riotgames.com/api-methods/#tournament-stub-v4/POST_createTournamentCode
			Path: /lol/tournament-stub/v4/codes
		*/
		create_tournament_code_response create_tournament_code
		(
			cho::platform_id a_platform,
			int64_t a_tournament_id,
			create_tournament_code_optional_args a_optional = create_tournament_code_optional_args(), 
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Creates a mock tournament provider and returns its ID.\n## Implementation Notes\nProviders will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-stub-v4/POST_registerProviderData
			Path: /lol/tournament-stub/v4/providers
		*/
		void register_provider_data_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, int32_t result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct register_provider_data_response
		{
			size_t response_code;
			int32_t result;
		};

		/* 
			Description: Creates a mock tournament provider and returns its ID.\n## Implementation Notes\nProviders will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
			Docs: https://developer.riotgames.com/api-methods/#tournament-stub-v4/POST_registerProviderData
			Path: /lol/tournament-stub/v4/providers
		*/
		register_provider_data_response register_provider_data
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Creates a mock tournament and returns its ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-stub-v4/POST_registerTournament
			Path: /lol/tournament-stub/v4/tournaments
		*/
		void register_tournament_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, int32_t result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct register_tournament_response
		{
			size_t response_code;
			int32_t result;
		};

		/* 
			Description: Creates a mock tournament and returns its ID.
			Docs: https://developer.riotgames.com/api-methods/#tournament-stub-v4/POST_registerTournament
			Path: /lol/tournament-stub/v4/tournaments
		*/
		register_tournament_response register_tournament
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Gets a mock list of lobby events by tournament code. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-stub-v4/GET_getLobbyEventsByCode
			Path: /lol/tournament-stub/v4/lobby-events/by-code/{tournamentCode}
		*/
		void get_lobby_events_by_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code, tournament_stub_v4::lobby_event_dtowrapper result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_lobby_events_by_code_response
		{
			size_t response_code;
			tournament_stub_v4::lobby_event_dtowrapper result;
		};

		/* 
			Description: Gets a mock list of lobby events by tournament code.
			Docs: https://developer.riotgames.com/api-methods/#tournament-stub-v4/GET_getLobbyEventsByCode
			Path: /lol/tournament-stub/v4/lobby-events/by-code/{tournamentCode}
		*/
		get_lobby_events_by_code_response get_lobby_events_by_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	namespace tournament_v4
	{
		struct lobby_event_dto
		{
			std::string event_type;
			std::string timestamp;
			std::string summoner_id;
		};

		struct lobby_event_dtowrapper
		{
			std::vector<tournament_v4::lobby_event_dto> event_list;
		};

		struct provider_registration_parameters
		{
			std::string url;
			std::string region;
		};

		struct tournament_code_dto
		{
			int32_t id;
			std::string map;
			std::string code;
			std::string region;
			std::string meta_data;
			std::string password;
			std::string pick_type;
			int32_t team_size;
			std::string lobby_name;
			int32_t provider_id;
			std::string spectators;
			std::vector<std::string> participants;
			int32_t tournament_id;
		};

		struct tournament_code_parameters
		{
			std::string map_type;
			std::string metadata;
			std::string pick_type;
			int32_t team_size;
			std::string spectator_type;
			std::vector<std::string> allowed_summoner_ids;
		};

		struct tournament_code_update_parameters
		{
			std::string map_type;
			std::string pick_type;
			std::string spectator_type;
			std::vector<std::string> allowed_summoner_ids;
		};

		struct tournament_registration_parameters
		{
			std::string name;
			int32_t provider_id;
		};

		/*
			Optional arguments for create_tournament_code
		*/
		struct create_tournament_code_optional_args
		{
			cho::optional<int32_t> count;
		};
		/* 
			Description: Create a tournament code for the given tournament. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/POST_createTournamentCode
			Path: /lol/tournament/v4/codes
		*/
		void create_tournament_code_async
		(
			cho::platform_id a_platform,
			int64_t a_tournament_id,
			create_tournament_code_optional_args a_optional = create_tournament_code_optional_args(), 
			std::function<void(size_t response_code, std::vector<std::string> result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct create_tournament_code_response
		{
			size_t response_code;
			std::vector<std::string> result;
		};

		/* 
			Description: Create a tournament code for the given tournament.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/POST_createTournamentCode
			Path: /lol/tournament/v4/codes
		*/
		create_tournament_code_response create_tournament_code
		(
			cho::platform_id a_platform,
			int64_t a_tournament_id,
			create_tournament_code_optional_args a_optional = create_tournament_code_optional_args(), 
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Creates a tournament provider and returns its ID.\n## Implementation Notes\nProviders will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/POST_registerProviderData
			Path: /lol/tournament/v4/providers
		*/
		void register_provider_data_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, int32_t result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct register_provider_data_response
		{
			size_t response_code;
			int32_t result;
		};

		/* 
			Description: Creates a tournament provider and returns its ID.\n## Implementation Notes\nProviders will need to call this endpoint first to register their callback URL and their API key with the tournament system before any other tournament provider endpoints will work.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/POST_registerProviderData
			Path: /lol/tournament/v4/providers
		*/
		register_provider_data_response register_provider_data
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Creates a tournament and returns its ID. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/POST_registerTournament
			Path: /lol/tournament/v4/tournaments
		*/
		void register_tournament_async
		(
			cho::platform_id a_platform,
			std::function<void(size_t response_code, int32_t result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct register_tournament_response
		{
			size_t response_code;
			int32_t result;
		};

		/* 
			Description: Creates a tournament and returns its ID.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/POST_registerTournament
			Path: /lol/tournament/v4/tournaments
		*/
		register_tournament_response register_tournament
		(
			cho::platform_id a_platform,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Returns the tournament code DTO associated with a tournament code string. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/GET_getTournamentCode
			Path: /lol/tournament/v4/codes/{tournamentCode}
		*/
		void get_tournament_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code, tournament_v4::tournament_code_dto result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_tournament_code_response
		{
			size_t response_code;
			tournament_v4::tournament_code_dto result;
		};

		/* 
			Description: Returns the tournament code DTO associated with a tournament code string.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/GET_getTournamentCode
			Path: /lol/tournament/v4/codes/{tournamentCode}
		*/
		get_tournament_code_response get_tournament_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Update the pick type, map, spectator type, or allowed summoners for a code. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/PUT_updateCode
			Path: /lol/tournament/v4/codes/{tournamentCode}
		*/
		void update_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct update_code_response
		{
			size_t response_code;
			
		};

		/* 
			Description: Update the pick type, map, spectator type, or allowed summoners for a code.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/PUT_updateCode
			Path: /lol/tournament/v4/codes/{tournamentCode}
		*/
		update_code_response update_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api = riot::api::get_global()
		);

		/* 
			Description: Gets a list of lobby events by tournament code. This method is async, running on a separate thread.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/GET_getLobbyEventsByCode
			Path: /lol/tournament/v4/lobby-events/by-code/{tournamentCode}
		*/
		void get_lobby_events_by_code_async
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			std::function<void(size_t response_code, tournament_v4::lobby_event_dtowrapper result)> a_callback = nullptr,
			riot::api* a_riot_api = riot::api::get_global()
		);

		struct get_lobby_events_by_code_response
		{
			size_t response_code;
			tournament_v4::lobby_event_dtowrapper result;
		};

		/* 
			Description: Gets a list of lobby events by tournament code.
			Docs: https://developer.riotgames.com/api-methods/#tournament-v4/GET_getLobbyEventsByCode
			Path: /lol/tournament/v4/lobby-events/by-code/{tournamentCode}
		*/
		get_lobby_events_by_code_response get_lobby_events_by_code
		(
			cho::platform_id a_platform,
			const char* a_tournament_code,
			riot::api* a_riot_api = riot::api::get_global()
		);

	}

	template<typename serialiser, typename type>
	void serialise(serialiser& a_serialiser, const char* a_name, type& a_type)
	{
		a_serialiser.serialise(a_name, a_type);
	}

	template<typename serialiser, typename type>
	void serialise(serialiser& a_serialiser, const char* a_name, std::vector<type>& a_array)
	{
		a_serialiser.on_array_enter(a_name, a_array);

		for (size_t i = 0; i < a_array.size(); i++)
		{
			auto str = std::to_string(i);
			serialise(a_serialiser, str.c_str(), a_array[i]);
		}
		
		a_serialiser.on_array_exit();
	}

	template<typename serialiser, typename type>
	void serialise(serialiser& a_serialiser, const char* a_name, std::set<type>& a_array)
	{
		a_serialiser.on_array_enter(a_name, a_array);

		for (size_t i = 0; i < a_array.size(); i++)
		{
			auto str = std::to_string(i);
			serialise(a_serialiser, str.c_str(), a_array[i]);
		}

		a_serialiser.on_array_exit();
	}
	
	template<typename T>
	std::string to_string(const T& a_type)
	{
		return std::to_string(a_type);
	}

	std::string to_string(const cho::champion_key& a_type);
	std::string to_string(const std::string& a_type);

	template<typename serialiser, typename key, typename value>
	void serialise(serialiser& a_serialiser, const char* a_name, std::map<key, value>& a_map)
	{
		a_serialiser.on_map_enter(a_name, a_map);

		for (auto& elem : a_map)
		{
			auto str = cho::to_string(elem.first);
			serialise(a_serialiser, str.c_str(), elem.second);
		}
		
		a_serialiser.on_map_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, champion_mastery_v4::champion_mastery_dto& a_champion_mastery_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_champion_mastery_dto;
		serialise(a_serialiser, "champion_id", parent.champion_id);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);
		serialise(a_serialiser, "chest_granted", parent.chest_granted);
		serialise(a_serialiser, "last_play_time", parent.last_play_time);
		serialise(a_serialiser, "tokens_earned", parent.tokens_earned);
		serialise(a_serialiser, "champion_level", parent.champion_level);
		serialise(a_serialiser, "champion_points", parent.champion_points);
		serialise(a_serialiser, "champion_points_since_last_level", parent.champion_points_since_last_level);
		serialise(a_serialiser, "champion_points_until_next_level", parent.champion_points_until_next_level);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, champion_v3::champion_info& a_champion_info)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_champion_info;
		serialise(a_serialiser, "free_champion_ids", parent.free_champion_ids);
		serialise(a_serialiser, "max_new_player_level", parent.max_new_player_level);
		serialise(a_serialiser, "free_champion_ids_for_new_players", parent.free_champion_ids_for_new_players);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, clash_v1::player_dto& a_player_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_player_dto;
		serialise(a_serialiser, "role", parent.role);
		serialise(a_serialiser, "team_id", parent.team_id);
		serialise(a_serialiser, "position", parent.position);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, clash_v1::team_dto& a_team_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_team_dto;
		serialise(a_serialiser, "id", parent.id);
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "tier", parent.tier);
		serialise(a_serialiser, "icon_id", parent.icon_id);
		serialise(a_serialiser, "captain", parent.captain);
		serialise(a_serialiser, "players", parent.players);
		serialise(a_serialiser, "abbreviation", parent.abbreviation);
		serialise(a_serialiser, "tournament_id", parent.tournament_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, clash_v1::tournament_phase_dto& a_tournament_phase_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_tournament_phase_dto;
		serialise(a_serialiser, "id", parent.id);
		serialise(a_serialiser, "cancelled", parent.cancelled);
		serialise(a_serialiser, "start_time", parent.start_time);
		serialise(a_serialiser, "registration_time", parent.registration_time);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, clash_v1::tournament_dto& a_tournament_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_tournament_dto;
		serialise(a_serialiser, "id", parent.id);
		serialise(a_serialiser, "name_key", parent.name_key);
		serialise(a_serialiser, "theme_id", parent.theme_id);
		serialise(a_serialiser, "schedule", parent.schedule);
		serialise(a_serialiser, "name_key_secondary", parent.name_key_secondary);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, league_exp_v4::mini_series_dto& a_mini_series_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_mini_series_dto;
		serialise(a_serialiser, "wins", parent.wins);
		serialise(a_serialiser, "losses", parent.losses);
		serialise(a_serialiser, "target", parent.target);
		serialise(a_serialiser, "progress", parent.progress);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, league_exp_v4::league_entry_dto& a_league_entry_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_league_entry_dto;
		serialise(a_serialiser, "rank", parent.rank);
		serialise(a_serialiser, "tier", parent.tier);
		serialise(a_serialiser, "wins", parent.wins);
		serialise(a_serialiser, "losses", parent.losses);
		serialise(a_serialiser, "veteran", parent.veteran);
		serialise(a_serialiser, "inactive", parent.inactive);
		serialise(a_serialiser, "league_id", parent.league_id);
		serialise(a_serialiser, "hot_streak", parent.hot_streak);
		serialise(a_serialiser, "queue_type", parent.queue_type);
		serialise(a_serialiser, "fresh_blood", parent.fresh_blood);
		serialise(a_serialiser, "mini_series", parent.mini_series);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);
		serialise(a_serialiser, "league_points", parent.league_points);
		serialise(a_serialiser, "summoner_name", parent.summoner_name);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, league_v4::mini_series_dto& a_mini_series_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_mini_series_dto;
		serialise(a_serialiser, "wins", parent.wins);
		serialise(a_serialiser, "losses", parent.losses);
		serialise(a_serialiser, "target", parent.target);
		serialise(a_serialiser, "progress", parent.progress);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, league_v4::league_entry_dto& a_league_entry_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_league_entry_dto;
		serialise(a_serialiser, "rank", parent.rank);
		serialise(a_serialiser, "tier", parent.tier);
		serialise(a_serialiser, "wins", parent.wins);
		serialise(a_serialiser, "losses", parent.losses);
		serialise(a_serialiser, "veteran", parent.veteran);
		serialise(a_serialiser, "inactive", parent.inactive);
		serialise(a_serialiser, "league_id", parent.league_id);
		serialise(a_serialiser, "hot_streak", parent.hot_streak);
		serialise(a_serialiser, "queue_type", parent.queue_type);
		serialise(a_serialiser, "fresh_blood", parent.fresh_blood);
		serialise(a_serialiser, "mini_series", parent.mini_series);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);
		serialise(a_serialiser, "league_points", parent.league_points);
		serialise(a_serialiser, "summoner_name", parent.summoner_name);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, league_v4::league_item_dto& a_league_item_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_league_item_dto;
		serialise(a_serialiser, "rank", parent.rank);
		serialise(a_serialiser, "wins", parent.wins);
		serialise(a_serialiser, "losses", parent.losses);
		serialise(a_serialiser, "veteran", parent.veteran);
		serialise(a_serialiser, "inactive", parent.inactive);
		serialise(a_serialiser, "hot_streak", parent.hot_streak);
		serialise(a_serialiser, "fresh_blood", parent.fresh_blood);
		serialise(a_serialiser, "mini_series", parent.mini_series);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);
		serialise(a_serialiser, "league_points", parent.league_points);
		serialise(a_serialiser, "summoner_name", parent.summoner_name);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, league_v4::league_list_dto& a_league_list_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_league_list_dto;
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "tier", parent.tier);
		serialise(a_serialiser, "queue", parent.queue);
		serialise(a_serialiser, "entries", parent.entries);
		serialise(a_serialiser, "league_id", parent.league_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, lol_status_v3::translation& a_translation)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_translation;
		serialise(a_serialiser, "locale", parent.locale);
		serialise(a_serialiser, "content", parent.content);
		serialise(a_serialiser, "heading", parent.heading);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, lol_status_v3::message& a_message)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_message;
		serialise(a_serialiser, "id", parent.id);
		serialise(a_serialiser, "author", parent.author);
		serialise(a_serialiser, "content", parent.content);
		serialise(a_serialiser, "severity", parent.severity);
		serialise(a_serialiser, "created_at", parent.created_at);
		serialise(a_serialiser, "updated_at", parent.updated_at);
		serialise(a_serialiser, "translations", parent.translations);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, lol_status_v3::incident& a_incident)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_incident;
		serialise(a_serialiser, "id", parent.id);
		serialise(a_serialiser, "active", parent.active);
		serialise(a_serialiser, "updates", parent.updates);
		serialise(a_serialiser, "created_at", parent.created_at);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, lol_status_v3::service& a_service)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_service;
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "slug", parent.slug);
		serialise(a_serialiser, "status", parent.status);
		serialise(a_serialiser, "incidents", parent.incidents);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, lol_status_v3::shard_status& a_shard_status)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_shard_status;
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "slug", parent.slug);
		serialise(a_serialiser, "locales", parent.locales);
		serialise(a_serialiser, "hostname", parent.hostname);
		serialise(a_serialiser, "services", parent.services);
		serialise(a_serialiser, "region_tag", parent.region_tag);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, lor_ranked_v1::player_dto& a_player_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_player_dto;
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "rank", parent.rank);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, lor_ranked_v1::leaderboard_dto& a_leaderboard_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_leaderboard_dto;
		serialise(a_serialiser, "players", parent.players);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::mastery_dto& a_mastery_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_mastery_dto;
		serialise(a_serialiser, "rank", parent.rank);
		serialise(a_serialiser, "mastery_id", parent.mastery_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::team_bans_dto& a_team_bans_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_team_bans_dto;
		serialise(a_serialiser, "pick_turn", parent.pick_turn);
		serialise(a_serialiser, "champion_id", parent.champion_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::team_stats_dto& a_team_stats_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_team_stats_dto;
		serialise(a_serialiser, "win", parent.win);
		serialise(a_serialiser, "bans", parent.bans);
		serialise(a_serialiser, "team_id", parent.team_id);
		serialise(a_serialiser, "baron_kills", parent.baron_kills);
		serialise(a_serialiser, "first_baron", parent.first_baron);
		serialise(a_serialiser, "first_blood", parent.first_blood);
		serialise(a_serialiser, "first_tower", parent.first_tower);
		serialise(a_serialiser, "tower_kills", parent.tower_kills);
		serialise(a_serialiser, "dragon_kills", parent.dragon_kills);
		serialise(a_serialiser, "first_dragon", parent.first_dragon);
		serialise(a_serialiser, "vilemaw_kills", parent.vilemaw_kills);
		serialise(a_serialiser, "first_inhibitor", parent.first_inhibitor);
		serialise(a_serialiser, "inhibitor_kills", parent.inhibitor_kills);
		serialise(a_serialiser, "first_rift_herald", parent.first_rift_herald);
		serialise(a_serialiser, "rift_herald_kills", parent.rift_herald_kills);
		serialise(a_serialiser, "dominion_victory_score", parent.dominion_victory_score);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::rune_dto& a_rune_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_rune_dto;
		serialise(a_serialiser, "rank", parent.rank);
		serialise(a_serialiser, "rune_id", parent.rune_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::participant_stats_dto& a_participant_stats_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_participant_stats_dto;
		serialise(a_serialiser, "win", parent.win);
		serialise(a_serialiser, "item0", parent.item0);
		serialise(a_serialiser, "item1", parent.item1);
		serialise(a_serialiser, "item2", parent.item2);
		serialise(a_serialiser, "item3", parent.item3);
		serialise(a_serialiser, "item4", parent.item4);
		serialise(a_serialiser, "item5", parent.item5);
		serialise(a_serialiser, "item6", parent.item6);
		serialise(a_serialiser, "kills", parent.kills);
		serialise(a_serialiser, "perk0", parent.perk0);
		serialise(a_serialiser, "perk1", parent.perk1);
		serialise(a_serialiser, "perk2", parent.perk2);
		serialise(a_serialiser, "perk3", parent.perk3);
		serialise(a_serialiser, "perk4", parent.perk4);
		serialise(a_serialiser, "perk5", parent.perk5);
		serialise(a_serialiser, "deaths", parent.deaths);
		serialise(a_serialiser, "assists", parent.assists);
		serialise(a_serialiser, "gold_spent", parent.gold_spent);
		serialise(a_serialiser, "perk0var1", parent.perk0var1);
		serialise(a_serialiser, "perk0var2", parent.perk0var2);
		serialise(a_serialiser, "perk0var3", parent.perk0var3);
		serialise(a_serialiser, "perk1var1", parent.perk1var1);
		serialise(a_serialiser, "perk1var2", parent.perk1var2);
		serialise(a_serialiser, "perk1var3", parent.perk1var3);
		serialise(a_serialiser, "perk2var1", parent.perk2var1);
		serialise(a_serialiser, "perk2var2", parent.perk2var2);
		serialise(a_serialiser, "perk2var3", parent.perk2var3);
		serialise(a_serialiser, "perk3var1", parent.perk3var1);
		serialise(a_serialiser, "perk3var2", parent.perk3var2);
		serialise(a_serialiser, "perk3var3", parent.perk3var3);
		serialise(a_serialiser, "perk4var1", parent.perk4var1);
		serialise(a_serialiser, "perk4var2", parent.perk4var2);
		serialise(a_serialiser, "perk4var3", parent.perk4var3);
		serialise(a_serialiser, "perk5var1", parent.perk5var1);
		serialise(a_serialiser, "perk5var2", parent.perk5var2);
		serialise(a_serialiser, "perk5var3", parent.perk5var3);
		serialise(a_serialiser, "total_heal", parent.total_heal);
		serialise(a_serialiser, "champ_level", parent.champ_level);
		serialise(a_serialiser, "gold_earned", parent.gold_earned);
		serialise(a_serialiser, "penta_kills", parent.penta_kills);
		serialise(a_serialiser, "double_kills", parent.double_kills);
		serialise(a_serialiser, "node_capture", parent.node_capture);
		serialise(a_serialiser, "quadra_kills", parent.quadra_kills);
		serialise(a_serialiser, "triple_kills", parent.triple_kills);
		serialise(a_serialiser, "turret_kills", parent.turret_kills);
		serialise(a_serialiser, "unreal_kills", parent.unreal_kills);
		serialise(a_serialiser, "vision_score", parent.vision_score);
		serialise(a_serialiser, "wards_killed", parent.wards_killed);
		serialise(a_serialiser, "wards_placed", parent.wards_placed);
		serialise(a_serialiser, "perk_sub_style", parent.perk_sub_style);
		serialise(a_serialiser, "player_score0", parent.player_score0);
		serialise(a_serialiser, "player_score1", parent.player_score1);
		serialise(a_serialiser, "player_score2", parent.player_score2);
		serialise(a_serialiser, "player_score3", parent.player_score3);
		serialise(a_serialiser, "player_score4", parent.player_score4);
		serialise(a_serialiser, "player_score5", parent.player_score5);
		serialise(a_serialiser, "player_score6", parent.player_score6);
		serialise(a_serialiser, "player_score7", parent.player_score7);
		serialise(a_serialiser, "player_score8", parent.player_score8);
		serialise(a_serialiser, "player_score9", parent.player_score9);
		serialise(a_serialiser, "killing_sprees", parent.killing_sprees);
		serialise(a_serialiser, "participant_id", parent.participant_id);
		serialise(a_serialiser, "team_objective", parent.team_objective);
		serialise(a_serialiser, "altars_captured", parent.altars_captured);
		serialise(a_serialiser, "first_blood_kill", parent.first_blood_kill);
		serialise(a_serialiser, "first_tower_kill", parent.first_tower_kill);
		serialise(a_serialiser, "inhibitor_kills", parent.inhibitor_kills);
		serialise(a_serialiser, "node_neutralize", parent.node_neutralize);
		serialise(a_serialiser, "total_score_rank", parent.total_score_rank);
		serialise(a_serialiser, "time_ccing_others", parent.time_ccing_others);
		serialise(a_serialiser, "true_damage_dealt", parent.true_damage_dealt);
		serialise(a_serialiser, "true_damage_taken", parent.true_damage_taken);
		serialise(a_serialiser, "first_blood_assist", parent.first_blood_assist);
		serialise(a_serialiser, "first_tower_assist", parent.first_tower_assist);
		serialise(a_serialiser, "largest_multi_kill", parent.largest_multi_kill);
		serialise(a_serialiser, "magic_damage_dealt", parent.magic_damage_dealt);
		serialise(a_serialiser, "perk_primary_style", parent.perk_primary_style);
		serialise(a_serialiser, "total_damage_dealt", parent.total_damage_dealt);
		serialise(a_serialiser, "total_damage_taken", parent.total_damage_taken);
		serialise(a_serialiser, "total_player_score", parent.total_player_score);
		serialise(a_serialiser, "total_units_healed", parent.total_units_healed);
		serialise(a_serialiser, "altars_neutralized", parent.altars_neutralized);
		serialise(a_serialiser, "combat_player_score", parent.combat_player_score);
		serialise(a_serialiser, "node_capture_assist", parent.node_capture_assist);
		serialise(a_serialiser, "first_inhibitor_kill", parent.first_inhibitor_kill);
		serialise(a_serialiser, "magical_damage_taken", parent.magical_damage_taken);
		serialise(a_serialiser, "total_minions_killed", parent.total_minions_killed);
		serialise(a_serialiser, "damage_self_mitigated", parent.damage_self_mitigated);
		serialise(a_serialiser, "largest_killing_spree", parent.largest_killing_spree);
		serialise(a_serialiser, "physical_damage_dealt", parent.physical_damage_dealt);
		serialise(a_serialiser, "physical_damage_taken", parent.physical_damage_taken);
		serialise(a_serialiser, "damage_dealt_to_turrets", parent.damage_dealt_to_turrets);
		serialise(a_serialiser, "first_inhibitor_assist", parent.first_inhibitor_assist);
		serialise(a_serialiser, "neutral_minions_killed", parent.neutral_minions_killed);
		serialise(a_serialiser, "node_neutralize_assist", parent.node_neutralize_assist);
		serialise(a_serialiser, "objective_player_score", parent.objective_player_score);
		serialise(a_serialiser, "largest_critical_strike", parent.largest_critical_strike);
		serialise(a_serialiser, "longest_time_spent_living", parent.longest_time_spent_living);
		serialise(a_serialiser, "sight_wards_bought_in_game", parent.sight_wards_bought_in_game);
		serialise(a_serialiser, "damage_dealt_to_objectives", parent.damage_dealt_to_objectives);
		serialise(a_serialiser, "vision_wards_bought_in_game", parent.vision_wards_bought_in_game);
		serialise(a_serialiser, "total_time_crowd_control_dealt", parent.total_time_crowd_control_dealt);
		serialise(a_serialiser, "true_damage_dealt_to_champions", parent.true_damage_dealt_to_champions);
		serialise(a_serialiser, "magic_damage_dealt_to_champions", parent.magic_damage_dealt_to_champions);
		serialise(a_serialiser, "total_damage_dealt_to_champions", parent.total_damage_dealt_to_champions);
		serialise(a_serialiser, "neutral_minions_killed_team_jungle", parent.neutral_minions_killed_team_jungle);
		serialise(a_serialiser, "physical_damage_dealt_to_champions", parent.physical_damage_dealt_to_champions);
		serialise(a_serialiser, "neutral_minions_killed_enemy_jungle", parent.neutral_minions_killed_enemy_jungle);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::participant_timeline_dto& a_participant_timeline_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_participant_timeline_dto;
		serialise(a_serialiser, "lane", parent.lane);
		serialise(a_serialiser, "role", parent.role);
		serialise(a_serialiser, "participant_id", parent.participant_id);
		serialise(a_serialiser, "xp_per_min_deltas", parent.xp_per_min_deltas);
		serialise(a_serialiser, "gold_per_min_deltas", parent.gold_per_min_deltas);
		serialise(a_serialiser, "creeps_per_min_deltas", parent.creeps_per_min_deltas);
		serialise(a_serialiser, "cs_diff_per_min_deltas", parent.cs_diff_per_min_deltas);
		serialise(a_serialiser, "xp_diff_per_min_deltas", parent.xp_diff_per_min_deltas);
		serialise(a_serialiser, "damage_taken_per_min_deltas", parent.damage_taken_per_min_deltas);
		serialise(a_serialiser, "damage_taken_diff_per_min_deltas", parent.damage_taken_diff_per_min_deltas);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::participant_dto& a_participant_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_participant_dto;
		serialise(a_serialiser, "runes", parent.runes);
		serialise(a_serialiser, "stats", parent.stats);
		serialise(a_serialiser, "team_id", parent.team_id);
		serialise(a_serialiser, "spell1id", parent.spell1id);
		serialise(a_serialiser, "spell2id", parent.spell2id);
		serialise(a_serialiser, "timeline", parent.timeline);
		serialise(a_serialiser, "masteries", parent.masteries);
		serialise(a_serialiser, "champion_id", parent.champion_id);
		serialise(a_serialiser, "participant_id", parent.participant_id);
		serialise(a_serialiser, "highest_achieved_season_tier", parent.highest_achieved_season_tier);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::player_dto& a_player_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_player_dto;
		serialise(a_serialiser, "account_id", parent.account_id);
		serialise(a_serialiser, "platform_id", parent.platform_id);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);
		serialise(a_serialiser, "profile_icon", parent.profile_icon);
		serialise(a_serialiser, "summoner_name", parent.summoner_name);
		serialise(a_serialiser, "match_history_uri", parent.match_history_uri);
		serialise(a_serialiser, "current_account_id", parent.current_account_id);
		serialise(a_serialiser, "current_platform_id", parent.current_platform_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::participant_identity_dto& a_participant_identity_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_participant_identity_dto;
		serialise(a_serialiser, "player", parent.player);
		serialise(a_serialiser, "participant_id", parent.participant_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::match_dto& a_match_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_match_dto;
		serialise(a_serialiser, "map_id", parent.map_id);
		serialise(a_serialiser, "teams", parent.teams);
		serialise(a_serialiser, "game_id", parent.game_id);
		serialise(a_serialiser, "queue_id", parent.queue_id);
		serialise(a_serialiser, "game_mode", parent.game_mode);
		serialise(a_serialiser, "game_type", parent.game_type);
		serialise(a_serialiser, "season_id", parent.season_id);
		serialise(a_serialiser, "platform_id", parent.platform_id);
		serialise(a_serialiser, "game_version", parent.game_version);
		serialise(a_serialiser, "game_creation", parent.game_creation);
		serialise(a_serialiser, "game_duration", parent.game_duration);
		serialise(a_serialiser, "participants", parent.participants);
		serialise(a_serialiser, "participant_identities", parent.participant_identities);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::match_position_dto& a_match_position_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_match_position_dto;
		serialise(a_serialiser, "x", parent.x);
		serialise(a_serialiser, "y", parent.y);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::match_event_dto& a_match_event_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_match_event_dto;
		serialise(a_serialiser, "type", parent.type);
		serialise(a_serialiser, "item_id", parent.item_id);
		serialise(a_serialiser, "team_id", parent.team_id);
		serialise(a_serialiser, "after_id", parent.after_id);
		serialise(a_serialiser, "before_id", parent.before_id);
		serialise(a_serialiser, "killer_id", parent.killer_id);
		serialise(a_serialiser, "lane_type", parent.lane_type);
		serialise(a_serialiser, "position", parent.position);
		serialise(a_serialiser, "victim_id", parent.victim_id);
		serialise(a_serialiser, "ward_type", parent.ward_type);
		serialise(a_serialiser, "creator_id", parent.creator_id);
		serialise(a_serialiser, "event_type", parent.event_type);
		serialise(a_serialiser, "skill_slot", parent.skill_slot);
		serialise(a_serialiser, "timestamp", parent.timestamp);
		serialise(a_serialiser, "tower_type", parent.tower_type);
		serialise(a_serialiser, "level_up_type", parent.level_up_type);
		serialise(a_serialiser, "monster_type", parent.monster_type);
		serialise(a_serialiser, "ascended_type", parent.ascended_type);
		serialise(a_serialiser, "building_type", parent.building_type);
		serialise(a_serialiser, "participant_id", parent.participant_id);
		serialise(a_serialiser, "point_captured", parent.point_captured);
		serialise(a_serialiser, "monster_sub_type", parent.monster_sub_type);
		serialise(a_serialiser, "assisting_participant_ids", parent.assisting_participant_ids);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::match_frame_dto& a_match_frame_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_match_frame_dto;
		serialise(a_serialiser, "events", parent.events);
		serialise(a_serialiser, "timestamp", parent.timestamp);
		serialise(a_serialiser, "participant_frames", parent.participant_frames);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::match_participant_frame_dto& a_match_participant_frame_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_match_participant_frame_dto;
		serialise(a_serialiser, "xp", parent.xp);
		serialise(a_serialiser, "level", parent.level);
		serialise(a_serialiser, "position", parent.position);
		serialise(a_serialiser, "team_score", parent.team_score);
		serialise(a_serialiser, "total_gold", parent.total_gold);
		serialise(a_serialiser, "current_gold", parent.current_gold);
		serialise(a_serialiser, "dominion_score", parent.dominion_score);
		serialise(a_serialiser, "minions_killed", parent.minions_killed);
		serialise(a_serialiser, "participant_id", parent.participant_id);
		serialise(a_serialiser, "jungle_minions_killed", parent.jungle_minions_killed);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::match_reference_dto& a_match_reference_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_match_reference_dto;
		serialise(a_serialiser, "lane", parent.lane);
		serialise(a_serialiser, "role", parent.role);
		serialise(a_serialiser, "queue", parent.queue);
		serialise(a_serialiser, "game_id", parent.game_id);
		serialise(a_serialiser, "season", parent.season);
		serialise(a_serialiser, "champion", parent.champion);
		serialise(a_serialiser, "timestamp", parent.timestamp);
		serialise(a_serialiser, "platform_id", parent.platform_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::match_timeline_dto& a_match_timeline_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_match_timeline_dto;
		serialise(a_serialiser, "frames", parent.frames);
		serialise(a_serialiser, "frame_interval", parent.frame_interval);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, match_v4::matchlist_dto& a_matchlist_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_matchlist_dto;
		serialise(a_serialiser, "matches", parent.matches);
		serialise(a_serialiser, "end_index", parent.end_index);
		serialise(a_serialiser, "start_index", parent.start_index);
		serialise(a_serialiser, "total_games", parent.total_games);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, spectator_v4::banned_champion& a_banned_champion)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_banned_champion;
		serialise(a_serialiser, "team_id", parent.team_id);
		serialise(a_serialiser, "pick_turn", parent.pick_turn);
		serialise(a_serialiser, "champion_id", parent.champion_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, spectator_v4::observer& a_observer)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_observer;
		serialise(a_serialiser, "encryption_key", parent.encryption_key);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, spectator_v4::perks& a_perks)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_perks;
		serialise(a_serialiser, "perk_ids", parent.perk_ids);
		serialise(a_serialiser, "perk_style", parent.perk_style);
		serialise(a_serialiser, "perk_sub_style", parent.perk_sub_style);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, spectator_v4::game_customization_object& a_game_customization_object)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_game_customization_object;
		serialise(a_serialiser, "content", parent.content);
		serialise(a_serialiser, "category", parent.category);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, spectator_v4::current_game_participant& a_current_game_participant)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_current_game_participant;
		serialise(a_serialiser, "bot", parent.bot);
		serialise(a_serialiser, "perks", parent.perks);
		serialise(a_serialiser, "team_id", parent.team_id);
		serialise(a_serialiser, "spell1id", parent.spell1id);
		serialise(a_serialiser, "spell2id", parent.spell2id);
		serialise(a_serialiser, "champion_id", parent.champion_id);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);
		serialise(a_serialiser, "summoner_name", parent.summoner_name);
		serialise(a_serialiser, "profile_icon_id", parent.profile_icon_id);
		serialise(a_serialiser, "game_customization_objects", parent.game_customization_objects);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, spectator_v4::current_game_info& a_current_game_info)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_current_game_info;
		serialise(a_serialiser, "map_id", parent.map_id);
		serialise(a_serialiser, "game_id", parent.game_id);
		serialise(a_serialiser, "game_mode", parent.game_mode);
		serialise(a_serialiser, "game_type", parent.game_type);
		serialise(a_serialiser, "observers", parent.observers);
		serialise(a_serialiser, "game_length", parent.game_length);
		serialise(a_serialiser, "platform_id", parent.platform_id);
		serialise(a_serialiser, "participants", parent.participants);
		serialise(a_serialiser, "game_start_time", parent.game_start_time);
		serialise(a_serialiser, "banned_champions", parent.banned_champions);
		serialise(a_serialiser, "game_queue_config_id", parent.game_queue_config_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, spectator_v4::participant& a_participant)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_participant;
		serialise(a_serialiser, "bot", parent.bot);
		serialise(a_serialiser, "team_id", parent.team_id);
		serialise(a_serialiser, "spell1id", parent.spell1id);
		serialise(a_serialiser, "spell2id", parent.spell2id);
		serialise(a_serialiser, "champion_id", parent.champion_id);
		serialise(a_serialiser, "summoner_name", parent.summoner_name);
		serialise(a_serialiser, "profile_icon_id", parent.profile_icon_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, spectator_v4::featured_game_info& a_featured_game_info)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_featured_game_info;
		serialise(a_serialiser, "map_id", parent.map_id);
		serialise(a_serialiser, "game_id", parent.game_id);
		serialise(a_serialiser, "game_mode", parent.game_mode);
		serialise(a_serialiser, "game_type", parent.game_type);
		serialise(a_serialiser, "observers", parent.observers);
		serialise(a_serialiser, "game_length", parent.game_length);
		serialise(a_serialiser, "platform_id", parent.platform_id);
		serialise(a_serialiser, "participants", parent.participants);
		serialise(a_serialiser, "game_start_time", parent.game_start_time);
		serialise(a_serialiser, "banned_champions", parent.banned_champions);
		serialise(a_serialiser, "game_queue_config_id", parent.game_queue_config_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, spectator_v4::featured_games& a_featured_games)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_featured_games;
		serialise(a_serialiser, "game_list", parent.game_list);
		serialise(a_serialiser, "client_refresh_interval", parent.client_refresh_interval);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, summoner_v4::summoner_dto& a_summoner_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_summoner_dto;
		serialise(a_serialiser, "id", parent.id);
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "puuid", parent.puuid);
		serialise(a_serialiser, "account_id", parent.account_id);
		serialise(a_serialiser, "revision_date", parent.revision_date);
		serialise(a_serialiser, "profile_icon_id", parent.profile_icon_id);
		serialise(a_serialiser, "summoner_level", parent.summoner_level);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_league_v1::mini_series_dto& a_mini_series_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_mini_series_dto;
		serialise(a_serialiser, "wins", parent.wins);
		serialise(a_serialiser, "losses", parent.losses);
		serialise(a_serialiser, "target", parent.target);
		serialise(a_serialiser, "progress", parent.progress);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_league_v1::league_entry_dto& a_league_entry_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_league_entry_dto;
		serialise(a_serialiser, "rank", parent.rank);
		serialise(a_serialiser, "tier", parent.tier);
		serialise(a_serialiser, "wins", parent.wins);
		serialise(a_serialiser, "losses", parent.losses);
		serialise(a_serialiser, "veteran", parent.veteran);
		serialise(a_serialiser, "inactive", parent.inactive);
		serialise(a_serialiser, "league_id", parent.league_id);
		serialise(a_serialiser, "hot_streak", parent.hot_streak);
		serialise(a_serialiser, "queue_type", parent.queue_type);
		serialise(a_serialiser, "fresh_blood", parent.fresh_blood);
		serialise(a_serialiser, "mini_series", parent.mini_series);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);
		serialise(a_serialiser, "league_points", parent.league_points);
		serialise(a_serialiser, "summoner_name", parent.summoner_name);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_league_v1::league_item_dto& a_league_item_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_league_item_dto;
		serialise(a_serialiser, "rank", parent.rank);
		serialise(a_serialiser, "wins", parent.wins);
		serialise(a_serialiser, "losses", parent.losses);
		serialise(a_serialiser, "veteran", parent.veteran);
		serialise(a_serialiser, "inactive", parent.inactive);
		serialise(a_serialiser, "hot_streak", parent.hot_streak);
		serialise(a_serialiser, "fresh_blood", parent.fresh_blood);
		serialise(a_serialiser, "mini_series", parent.mini_series);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);
		serialise(a_serialiser, "league_points", parent.league_points);
		serialise(a_serialiser, "summoner_name", parent.summoner_name);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_league_v1::league_list_dto& a_league_list_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_league_list_dto;
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "tier", parent.tier);
		serialise(a_serialiser, "queue", parent.queue);
		serialise(a_serialiser, "entries", parent.entries);
		serialise(a_serialiser, "league_id", parent.league_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_match_v1::companion_dto& a_companion_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_companion_dto;
		serialise(a_serialiser, "skin_id", parent.skin_id);
		serialise(a_serialiser, "species", parent.species);
		serialise(a_serialiser, "content_id", parent.content_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_match_v1::unit_dto& a_unit_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_unit_dto;
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "tier", parent.tier);
		serialise(a_serialiser, "items", parent.items);
		serialise(a_serialiser, "rarity", parent.rarity);
		serialise(a_serialiser, "character_id", parent.character_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_match_v1::trait_dto& a_trait_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_trait_dto;
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "num_units", parent.num_units);
		serialise(a_serialiser, "tier_total", parent.tier_total);
		serialise(a_serialiser, "tier_current", parent.tier_current);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_match_v1::participant_dto& a_participant_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_participant_dto;
		serialise(a_serialiser, "level", parent.level);
		serialise(a_serialiser, "puuid", parent.puuid);
		serialise(a_serialiser, "units", parent.units);
		serialise(a_serialiser, "traits", parent.traits);
		serialise(a_serialiser, "companion", parent.companion);
		serialise(a_serialiser, "gold_left", parent.gold_left);
		serialise(a_serialiser, "placement", parent.placement);
		serialise(a_serialiser, "last_round", parent.last_round);
		serialise(a_serialiser, "time_eliminated", parent.time_eliminated);
		serialise(a_serialiser, "players_eliminated", parent.players_eliminated);
		serialise(a_serialiser, "total_damage_to_players", parent.total_damage_to_players);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_match_v1::info_dto& a_info_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_info_dto;
		serialise(a_serialiser, "queue_id", parent.queue_id);
		serialise(a_serialiser, "game_length", parent.game_length);
		serialise(a_serialiser, "game_version", parent.game_version);
		serialise(a_serialiser, "participants", parent.participants);
		serialise(a_serialiser, "game_datetime", parent.game_datetime);
		serialise(a_serialiser, "tft_set_number", parent.tft_set_number);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_match_v1::metadata_dto& a_metadata_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_metadata_dto;
		serialise(a_serialiser, "match_id", parent.match_id);
		serialise(a_serialiser, "data_version", parent.data_version);
		serialise(a_serialiser, "participants", parent.participants);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_match_v1::match_dto& a_match_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_match_dto;
		serialise(a_serialiser, "info", parent.info);
		serialise(a_serialiser, "metadata", parent.metadata);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tft_summoner_v1::summoner_dto& a_summoner_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_summoner_dto;
		serialise(a_serialiser, "id", parent.id);
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "puuid", parent.puuid);
		serialise(a_serialiser, "account_id", parent.account_id);
		serialise(a_serialiser, "revision_date", parent.revision_date);
		serialise(a_serialiser, "profile_icon_id", parent.profile_icon_id);
		serialise(a_serialiser, "summoner_level", parent.summoner_level);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_stub_v4::lobby_event_dto& a_lobby_event_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_lobby_event_dto;
		serialise(a_serialiser, "event_type", parent.event_type);
		serialise(a_serialiser, "timestamp", parent.timestamp);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_stub_v4::lobby_event_dtowrapper& a_lobby_event_dtowrapper)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_lobby_event_dtowrapper;
		serialise(a_serialiser, "event_list", parent.event_list);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_stub_v4::provider_registration_parameters& a_provider_registration_parameters)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_provider_registration_parameters;
		serialise(a_serialiser, "url", parent.url);
		serialise(a_serialiser, "region", parent.region);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_stub_v4::tournament_code_parameters& a_tournament_code_parameters)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_tournament_code_parameters;
		serialise(a_serialiser, "map_type", parent.map_type);
		serialise(a_serialiser, "metadata", parent.metadata);
		serialise(a_serialiser, "pick_type", parent.pick_type);
		serialise(a_serialiser, "team_size", parent.team_size);
		serialise(a_serialiser, "spectator_type", parent.spectator_type);
		serialise(a_serialiser, "allowed_summoner_ids", parent.allowed_summoner_ids);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_stub_v4::tournament_registration_parameters& a_tournament_registration_parameters)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_tournament_registration_parameters;
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "provider_id", parent.provider_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_v4::lobby_event_dto& a_lobby_event_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_lobby_event_dto;
		serialise(a_serialiser, "event_type", parent.event_type);
		serialise(a_serialiser, "timestamp", parent.timestamp);
		serialise(a_serialiser, "summoner_id", parent.summoner_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_v4::lobby_event_dtowrapper& a_lobby_event_dtowrapper)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_lobby_event_dtowrapper;
		serialise(a_serialiser, "event_list", parent.event_list);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_v4::provider_registration_parameters& a_provider_registration_parameters)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_provider_registration_parameters;
		serialise(a_serialiser, "url", parent.url);
		serialise(a_serialiser, "region", parent.region);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_v4::tournament_code_dto& a_tournament_code_dto)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_tournament_code_dto;
		serialise(a_serialiser, "id", parent.id);
		serialise(a_serialiser, "map", parent.map);
		serialise(a_serialiser, "code", parent.code);
		serialise(a_serialiser, "region", parent.region);
		serialise(a_serialiser, "meta_data", parent.meta_data);
		serialise(a_serialiser, "password", parent.password);
		serialise(a_serialiser, "pick_type", parent.pick_type);
		serialise(a_serialiser, "team_size", parent.team_size);
		serialise(a_serialiser, "lobby_name", parent.lobby_name);
		serialise(a_serialiser, "provider_id", parent.provider_id);
		serialise(a_serialiser, "spectators", parent.spectators);
		serialise(a_serialiser, "participants", parent.participants);
		serialise(a_serialiser, "tournament_id", parent.tournament_id);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_v4::tournament_code_parameters& a_tournament_code_parameters)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_tournament_code_parameters;
		serialise(a_serialiser, "map_type", parent.map_type);
		serialise(a_serialiser, "metadata", parent.metadata);
		serialise(a_serialiser, "pick_type", parent.pick_type);
		serialise(a_serialiser, "team_size", parent.team_size);
		serialise(a_serialiser, "spectator_type", parent.spectator_type);
		serialise(a_serialiser, "allowed_summoner_ids", parent.allowed_summoner_ids);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_v4::tournament_code_update_parameters& a_tournament_code_update_parameters)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_tournament_code_update_parameters;
		serialise(a_serialiser, "map_type", parent.map_type);
		serialise(a_serialiser, "pick_type", parent.pick_type);
		serialise(a_serialiser, "spectator_type", parent.spectator_type);
		serialise(a_serialiser, "allowed_summoner_ids", parent.allowed_summoner_ids);

		a_serialiser.on_struct_exit();
	}

	template<typename serialiser>
	void serialise(serialiser& a_serialiser, const char* a_name, tournament_v4::tournament_registration_parameters& a_tournament_registration_parameters)
	{
		a_serialiser.on_struct_enter(a_name);
		
		auto& parent = a_tournament_registration_parameters;
		serialise(a_serialiser, "name", parent.name);
		serialise(a_serialiser, "provider_id", parent.provider_id);

		a_serialiser.on_struct_exit();
	}
}